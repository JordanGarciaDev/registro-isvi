import {
  __commonJS
} from "./chunk-6TJCVOLN.js";

// node_modules/mdb-ui-kit/js/mdb.umd.min.js
var require_mdb_umd_min = __commonJS({
  "node_modules/mdb-ui-kit/js/mdb.umd.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).mdb = {});
    }(exports, function(t) {
      "use strict";
      var e = Object.defineProperty, i = (t2, i2, n2) => (((t3, i3, n3) => {
        i3 in t3 ? e(t3, i3, { enumerable: true, configurable: true, writable: true, value: n3 }) : t3[i3] = n3;
      })(t2, "symbol" != typeof i2 ? i2 + "" : i2, n2), n2);
      const n = (() => {
        const t2 = {};
        let e2 = 1;
        return { set(i2, n2, s2) {
          void 0 === i2[n2] && (i2[n2] = { key: n2, id: e2 }, e2++), t2[i2[n2].id] = s2;
        }, get(e3, i2) {
          if (!e3 || void 0 === e3[i2])
            return null;
          const n2 = e3[i2];
          return n2.key === i2 ? t2[n2.id] : null;
        }, delete(e3, i2) {
          if (void 0 === e3[i2])
            return;
          const n2 = e3[i2];
          n2.key === i2 && (delete t2[n2.id], delete e3[i2]);
        } };
      })(), s = { setData(t2, e2, i2) {
        n.set(t2, e2, i2);
      }, getData: (t2, e2) => n.get(t2, e2), removeData(t2, e2) {
        n.delete(t2, e2);
      } }, o = (t2) => {
        let e2 = t2.getAttribute("data-mdb-target");
        if (!e2 || "#" === e2) {
          const i2 = t2.getAttribute("href");
          e2 = i2 && "#" !== i2 ? i2.trim() : null;
        }
        return e2;
      }, r = (t2) => {
        const e2 = o(t2);
        return e2 && document.querySelector(e2) ? e2 : null;
      }, a = (t2) => {
        const e2 = o(t2);
        return e2 ? document.querySelector(e2) : null;
      }, l = (t2) => !(!t2 || "object" != typeof t2) && (void 0 !== t2.jquery && (t2 = t2[0]), void 0 !== t2.nodeType), c = (t2) => l(t2) ? t2.jquery ? t2[0] : t2 : "string" == typeof t2 && t2.length > 0 ? document.querySelector(t2) : null, h = (t2, e2, i2) => {
        Object.keys(i2).forEach((n2) => {
          const s2 = i2[n2], o2 = e2[n2], r2 = o2 && l(o2) ? "element" : null == (a2 = o2) ? `${a2}` : {}.toString.call(a2).match(/\s([a-z]+)/i)[1].toLowerCase();
          var a2;
          if (!new RegExp(s2).test(r2))
            throw new Error(`${t2.toUpperCase()}: Option "${n2}" provided type "${r2}" but expected type "${s2}".`);
        });
      }, d = (t2) => {
        if (!t2)
          return false;
        if (t2.style && t2.parentNode && t2.parentNode.style) {
          const e2 = getComputedStyle(t2), i2 = getComputedStyle(t2.parentNode);
          return "none" !== e2.display && "none" !== i2.display && "hidden" !== e2.visibility;
        }
        return false;
      }, u = (t2) => !t2 || t2.nodeType !== Node.ELEMENT_NODE || (!!t2.classList.contains("disabled") || (void 0 !== t2.disabled ? t2.disabled : t2.hasAttribute("disabled") && "false" !== t2.getAttribute("disabled"))), f = () => {
        const { jQuery: t2 } = window;
        return t2 && !document.body.hasAttribute("data-mdb-no-jquery") ? t2 : null;
      }, p = (t2) => {
        "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", t2) : t2();
      };
      document.documentElement.dir;
      const m = (t2) => document.createElement(t2), g = f(), _ = /[^.]*(?=\..*)\.|.*/, b = /\..*/, v = /::\d+$/, y = {};
      let w = 1;
      const E = { mouseenter: "mouseover", mouseleave: "mouseout" }, A = ["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"];
      function C(t2, e2) {
        return e2 && `${e2}::${w++}` || t2.uidEvent || w++;
      }
      function T(t2) {
        const e2 = C(t2);
        return t2.uidEvent = e2, y[e2] = y[e2] || {}, y[e2];
      }
      function O(t2, e2, i2 = null) {
        const n2 = Object.keys(t2);
        for (let s2 = 0, o2 = n2.length; s2 < o2; s2++) {
          const o3 = t2[n2[s2]];
          if (o3.originalHandler === e2 && o3.delegationSelector === i2)
            return o3;
        }
        return null;
      }
      function x(t2, e2, i2) {
        const n2 = "string" == typeof e2, s2 = n2 ? i2 : e2;
        let o2 = t2.replace(b, "");
        const r2 = E[o2];
        r2 && (o2 = r2);
        return A.indexOf(o2) > -1 || (o2 = t2), [n2, s2, o2];
      }
      function L(t2, e2, i2, n2, s2) {
        if ("string" != typeof e2 || !t2)
          return;
        i2 || (i2 = n2, n2 = null);
        const [o2, r2, a2] = x(e2, i2, n2), l2 = T(t2), c2 = l2[a2] || (l2[a2] = {}), h2 = O(c2, r2, o2 ? i2 : null);
        if (h2)
          return void (h2.oneOff = h2.oneOff && s2);
        const d2 = C(r2, e2.replace(_, "")), u2 = o2 ? function(t3, e3, i3) {
          return function n3(s3) {
            const o3 = t3.querySelectorAll(e3);
            for (let { target: e4 } = s3; e4 && e4 !== this; e4 = e4.parentNode)
              for (let r3 = o3.length; r3--; "")
                if (o3[r3] === e4)
                  return s3.delegateTarget = e4, n3.oneOff && D.off(t3, s3.type, i3), i3.apply(e4, [s3]);
            return null;
          };
        }(t2, i2, n2) : function(t3, e3) {
          return function i3(n3) {
            return n3.delegateTarget = t3, i3.oneOff && D.off(t3, n3.type, e3), e3.apply(t3, [n3]);
          };
        }(t2, i2);
        u2.delegationSelector = o2 ? i2 : null, u2.originalHandler = r2, u2.oneOff = s2, u2.uidEvent = d2, c2[d2] = u2, t2.addEventListener(a2, u2, o2);
      }
      function $(t2, e2, i2, n2, s2) {
        const o2 = O(e2[i2], n2, s2);
        o2 && (t2.removeEventListener(i2, o2, Boolean(s2)), delete e2[i2][o2.uidEvent]);
      }
      const D = { on(t2, e2, i2, n2) {
        L(t2, e2, i2, n2, false);
      }, one(t2, e2, i2, n2) {
        L(t2, e2, i2, n2, true);
      }, extend(t2, e2, i2) {
        e2.forEach((e3) => {
          D.on(t2, `${e3.name}.bs.${i2}`, (n2) => {
            const s2 = {};
            e3.parametersToCopy && e3.parametersToCopy.forEach((t3) => {
              s2[t3] = n2[t3];
            });
            D.trigger(t2, `${e3.name}.mdb.${i2}`, s2).defaultPrevented && n2.preventDefault();
          });
        });
      }, off(t2, e2, i2, n2) {
        if ("string" != typeof e2 || !t2)
          return;
        const [s2, o2, r2] = x(e2, i2, n2), a2 = r2 !== e2, l2 = T(t2), c2 = "." === e2.charAt(0);
        if (void 0 !== o2) {
          if (!l2 || !l2[r2])
            return;
          return void $(t2, l2, r2, o2, s2 ? i2 : null);
        }
        c2 && Object.keys(l2).forEach((i3) => {
          !function(t3, e3, i4, n3) {
            const s3 = e3[i4] || {};
            Object.keys(s3).forEach((o3) => {
              if (o3.indexOf(n3) > -1) {
                const n4 = s3[o3];
                $(t3, e3, i4, n4.originalHandler, n4.delegationSelector);
              }
            });
          }(t2, l2, i3, e2.slice(1));
        });
        const h2 = l2[r2] || {};
        Object.keys(h2).forEach((i3) => {
          const n3 = i3.replace(v, "");
          if (!a2 || e2.indexOf(n3) > -1) {
            const e3 = h2[i3];
            $(t2, l2, r2, e3.originalHandler, e3.delegationSelector);
          }
        });
      }, trigger(t2, e2, i2) {
        if ("string" != typeof e2 || !t2)
          return null;
        const n2 = e2.replace(b, ""), s2 = e2 !== n2, o2 = A.indexOf(n2) > -1;
        let r2, a2 = true, l2 = true, c2 = false, h2 = null;
        return s2 && g && (r2 = g.Event(e2, i2), g(t2).trigger(r2), a2 = !r2.isPropagationStopped(), l2 = !r2.isImmediatePropagationStopped(), c2 = r2.isDefaultPrevented()), o2 ? (h2 = document.createEvent("HTMLEvents"), h2.initEvent(n2, a2, true)) : h2 = new CustomEvent(e2, { bubbles: a2, cancelable: true }), void 0 !== i2 && Object.keys(i2).forEach((t3) => {
          Object.defineProperty(h2, t3, { get: () => i2[t3] });
        }), c2 && h2.preventDefault(), l2 && t2.dispatchEvent(h2), h2.defaultPrevented && void 0 !== r2 && r2.preventDefault(), h2;
      } };
      function k(t2) {
        return "true" === t2 || "false" !== t2 && (t2 === Number(t2).toString() ? Number(t2) : "" === t2 || "null" === t2 ? null : t2);
      }
      function N(t2) {
        return t2.replace(/[A-Z]/g, (t3) => `-${t3.toLowerCase()}`);
      }
      const M = { setDataAttribute(t2, e2, i2) {
        t2.setAttribute(`data-mdb-${N(e2)}`, i2);
      }, removeDataAttribute(t2, e2) {
        t2.removeAttribute(`data-mdb-${N(e2)}`);
      }, getDataAttributes(t2) {
        if (!t2)
          return {};
        const e2 = { ...t2.dataset };
        return Object.keys(e2).filter((t3) => t3.startsWith("mdb")).forEach((t3) => {
          let i2 = t3.replace(/^mdb/, "");
          i2 = i2.charAt(0).toLowerCase() + i2.slice(1, i2.length), e2[i2] = k(e2[t3]);
        }), e2;
      }, getDataAttribute: (t2, e2) => k(t2.getAttribute(`data-mdb-${N(e2)}`)), offset(t2) {
        const e2 = t2.getBoundingClientRect();
        return { top: e2.top + document.body.scrollTop, left: e2.left + document.body.scrollLeft };
      }, position: (t2) => ({ top: t2.offsetTop, left: t2.offsetLeft }), style(t2, e2) {
        Object.assign(t2.style, e2);
      }, toggleClass(t2, e2) {
        t2 && (t2.classList.contains(e2) ? t2.classList.remove(e2) : t2.classList.add(e2));
      }, addClass(t2, e2) {
        t2.classList.contains(e2) || t2.classList.add(e2);
      }, addStyle(t2, e2) {
        Object.keys(e2).forEach((i2) => {
          t2.style[i2] = e2[i2];
        });
      }, removeClass(t2, e2) {
        t2.classList.contains(e2) && t2.classList.remove(e2);
      }, hasClass: (t2, e2) => t2.classList.contains(e2) }, S = { closest: (t2, e2) => t2.closest(e2), matches: (t2, e2) => t2.matches(e2), find: (t2, e2 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e2, t2)), findOne: (t2, e2 = document.documentElement) => Element.prototype.querySelector.call(e2, t2), children: (t2, e2) => [].concat(...t2.children).filter((t3) => t3.matches(e2)), parents(t2, e2) {
        const i2 = [];
        let n2 = t2.parentNode;
        for (; n2 && n2.nodeType === Node.ELEMENT_NODE && 3 !== n2.nodeType; )
          this.matches(n2, e2) && i2.push(n2), n2 = n2.parentNode;
        return i2;
      }, prev(t2, e2) {
        let i2 = t2.previousElementSibling;
        for (; i2; ) {
          if (i2.matches(e2))
            return [i2];
          i2 = i2.previousElementSibling;
        }
        return [];
      }, next(t2, e2) {
        let i2 = t2.nextElementSibling;
        for (; i2; ) {
          if (this.matches(i2, e2))
            return [i2];
          i2 = i2.nextElementSibling;
        }
        return [];
      } }, I = /* @__PURE__ */ new Map(), P = { set(t2, e2, i2) {
        I.has(t2) || I.set(t2, /* @__PURE__ */ new Map());
        const n2 = I.get(t2);
        n2.has(e2) || 0 === n2.size ? n2.set(e2, i2) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n2.keys())[0]}.`);
      }, get: (t2, e2) => I.has(t2) && I.get(t2).get(e2) || null, remove(t2, e2) {
        if (!I.has(t2))
          return;
        const i2 = I.get(t2);
        i2.delete(e2), 0 === i2.size && I.delete(t2);
      } }, j = "transitionend", H = (t2) => (t2 && window.CSS && window.CSS.escape && (t2 = t2.replace(/#([^\s"#']+)/g, (t3, e2) => `#${CSS.escape(e2)}`)), t2), z = (t2) => {
        t2.dispatchEvent(new Event(j));
      }, R = (t2) => !(!t2 || "object" != typeof t2) && (void 0 !== t2.jquery && (t2 = t2[0]), void 0 !== t2.nodeType), B = (t2) => R(t2) ? t2.jquery ? t2[0] : t2 : "string" == typeof t2 && t2.length > 0 ? document.querySelector(H(t2)) : null, W = (t2) => {
        if (!R(t2) || 0 === t2.getClientRects().length)
          return false;
        const e2 = "visible" === getComputedStyle(t2).getPropertyValue("visibility"), i2 = t2.closest("details:not([open])");
        if (!i2)
          return e2;
        if (i2 !== t2) {
          const e3 = t2.closest("summary");
          if (e3 && e3.parentNode !== i2)
            return false;
          if (null === e3)
            return false;
        }
        return e2;
      }, F = (t2) => !t2 || t2.nodeType !== Node.ELEMENT_NODE || (!!t2.classList.contains("disabled") || (void 0 !== t2.disabled ? t2.disabled : t2.hasAttribute("disabled") && "false" !== t2.getAttribute("disabled"))), q = (t2) => {
        if (!document.documentElement.attachShadow)
          return null;
        if ("function" == typeof t2.getRootNode) {
          const e2 = t2.getRootNode();
          return e2 instanceof ShadowRoot ? e2 : null;
        }
        return t2 instanceof ShadowRoot ? t2 : t2.parentNode ? q(t2.parentNode) : null;
      }, V = () => {
      }, Y = (t2) => {
        t2.offsetHeight;
      }, U = () => "rtl" === document.documentElement.dir, K = (t2, e2 = [], i2 = t2) => "function" == typeof t2 ? t2(...e2) : i2, X = (t2, e2, i2 = true) => {
        if (!i2)
          return void K(t2);
        const n2 = ((t3) => {
          if (!t3)
            return 0;
          let { transitionDuration: e3, transitionDelay: i3 } = window.getComputedStyle(t3);
          const n3 = Number.parseFloat(e3), s3 = Number.parseFloat(i3);
          return n3 || s3 ? (e3 = e3.split(",")[0], i3 = i3.split(",")[0], 1e3 * (Number.parseFloat(e3) + Number.parseFloat(i3))) : 0;
        })(e2) + 5;
        let s2 = false;
        const o2 = ({ target: i3 }) => {
          i3 === e2 && (s2 = true, e2.removeEventListener(j, o2), K(t2));
        };
        e2.addEventListener(j, o2), setTimeout(() => {
          s2 || z(e2);
        }, n2);
      }, Q = (t2, e2, i2, n2) => {
        const s2 = t2.length;
        let o2 = t2.indexOf(e2);
        return -1 === o2 ? !i2 && n2 ? t2[s2 - 1] : t2[0] : (o2 += i2 ? 1 : -1, n2 && (o2 = (o2 + s2) % s2), t2[Math.max(0, Math.min(o2, s2 - 1))]);
      }, G = /[^.]*(?=\..*)\.|.*/, Z = /\..*/, J = /::\d+$/, tt = {};
      let et = 1;
      const it = { mouseenter: "mouseover", mouseleave: "mouseout" }, nt = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
      function st(t2, e2) {
        return e2 && `${e2}::${et++}` || t2.uidEvent || et++;
      }
      function ot(t2) {
        const e2 = st(t2);
        return t2.uidEvent = e2, tt[e2] = tt[e2] || {}, tt[e2];
      }
      function rt(t2, e2, i2 = null) {
        return Object.values(t2).find((t3) => t3.callable === e2 && t3.delegationSelector === i2);
      }
      function at(t2, e2, i2) {
        const n2 = "string" == typeof e2, s2 = n2 ? i2 : e2 || i2;
        let o2 = dt(t2);
        return nt.has(o2) || (o2 = t2), [n2, s2, o2];
      }
      function lt(t2, e2, i2, n2, s2) {
        if ("string" != typeof e2 || !t2)
          return;
        let [o2, r2, a2] = at(e2, i2, n2);
        if (e2 in it) {
          r2 = ((t3) => function(e3) {
            if (!e3.relatedTarget || e3.relatedTarget !== e3.delegateTarget && !e3.delegateTarget.contains(e3.relatedTarget))
              return t3.call(this, e3);
          })(r2);
        }
        const l2 = ot(t2), c2 = l2[a2] || (l2[a2] = {}), h2 = rt(c2, r2, o2 ? i2 : null);
        if (h2)
          return void (h2.oneOff = h2.oneOff && s2);
        const d2 = st(r2, e2.replace(G, "")), u2 = o2 ? function(t3, e3, i3) {
          return function n3(s3) {
            const o3 = t3.querySelectorAll(e3);
            for (let { target: r3 } = s3; r3 && r3 !== this; r3 = r3.parentNode)
              for (const a3 of o3)
                if (a3 === r3)
                  return ft(s3, { delegateTarget: r3 }), n3.oneOff && ut.off(t3, s3.type, e3, i3), i3.apply(r3, [s3]);
          };
        }(t2, i2, r2) : function(t3, e3) {
          return function i3(n3) {
            return ft(n3, { delegateTarget: t3 }), i3.oneOff && ut.off(t3, n3.type, e3), e3.apply(t3, [n3]);
          };
        }(t2, r2);
        u2.delegationSelector = o2 ? i2 : null, u2.callable = r2, u2.oneOff = s2, u2.uidEvent = d2, c2[d2] = u2, t2.addEventListener(a2, u2, o2);
      }
      function ct(t2, e2, i2, n2, s2) {
        const o2 = rt(e2[i2], n2, s2);
        o2 && (t2.removeEventListener(i2, o2, Boolean(s2)), delete e2[i2][o2.uidEvent]);
      }
      function ht(t2, e2, i2, n2) {
        const s2 = e2[i2] || {};
        for (const [o2, r2] of Object.entries(s2))
          o2.includes(n2) && ct(t2, e2, i2, r2.callable, r2.delegationSelector);
      }
      function dt(t2) {
        return t2 = t2.replace(Z, ""), it[t2] || t2;
      }
      const ut = { on(t2, e2, i2, n2) {
        lt(t2, e2, i2, n2, false);
      }, one(t2, e2, i2, n2) {
        lt(t2, e2, i2, n2, true);
      }, off(t2, e2, i2, n2) {
        if ("string" != typeof e2 || !t2)
          return;
        const [s2, o2, r2] = at(e2, i2, n2), a2 = r2 !== e2, l2 = ot(t2), c2 = l2[r2] || {}, h2 = e2.startsWith(".");
        if (void 0 === o2) {
          if (h2)
            for (const i3 of Object.keys(l2))
              ht(t2, l2, i3, e2.slice(1));
          for (const [i3, n3] of Object.entries(c2)) {
            const s3 = i3.replace(J, "");
            a2 && !e2.includes(s3) || ct(t2, l2, r2, n3.callable, n3.delegationSelector);
          }
        } else {
          if (!Object.keys(c2).length)
            return;
          ct(t2, l2, r2, o2, s2 ? i2 : null);
        }
      }, trigger(t2, e2, i2) {
        if ("string" != typeof e2 || !t2)
          return null;
        const n2 = window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null;
        let s2 = null, o2 = true, r2 = true, a2 = false;
        e2 !== dt(e2) && n2 && (s2 = n2.Event(e2, i2), n2(t2).trigger(s2), o2 = !s2.isPropagationStopped(), r2 = !s2.isImmediatePropagationStopped(), a2 = s2.isDefaultPrevented());
        const l2 = ft(new Event(e2, { bubbles: o2, cancelable: true }), i2);
        return a2 && l2.preventDefault(), r2 && t2.dispatchEvent(l2), l2.defaultPrevented && s2 && s2.preventDefault(), l2;
      } };
      function ft(t2, e2 = {}) {
        for (const [i2, n2] of Object.entries(e2))
          try {
            t2[i2] = n2;
          } catch {
            Object.defineProperty(t2, i2, { configurable: true, get: () => n2 });
          }
        return t2;
      }
      function pt(t2) {
        if ("true" === t2)
          return true;
        if ("false" === t2)
          return false;
        if (t2 === Number(t2).toString())
          return Number(t2);
        if ("" === t2 || "null" === t2)
          return null;
        if ("string" != typeof t2)
          return t2;
        try {
          return JSON.parse(decodeURIComponent(t2));
        } catch {
          return t2;
        }
      }
      function mt(t2) {
        return t2.replace(/[A-Z]/g, (t3) => `-${t3.toLowerCase()}`);
      }
      const gt = { setDataAttribute(t2, e2, i2) {
        t2.setAttribute(`data-mdb-${mt(e2)}`, i2);
      }, removeDataAttribute(t2, e2) {
        t2.removeAttribute(`data-mdb-${mt(e2)}`);
      }, getDataAttributes(t2) {
        if (!t2)
          return {};
        const e2 = {}, i2 = Object.keys(t2.dataset).filter((t3) => t3.startsWith("mdb") && !t3.startsWith("mdbConfig"));
        for (const n2 of i2) {
          let i3 = n2.replace(/^mdb/, "");
          i3 = i3.charAt(0).toLowerCase() + i3.slice(1, i3.length), e2[i3] = pt(t2.dataset[n2]);
        }
        return e2;
      }, getDataAttribute: (t2, e2) => pt(t2.getAttribute(`data-mdb-${mt(e2)}`)) };
      class _t {
        static get Default() {
          return {};
        }
        static get DefaultType() {
          return {};
        }
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
        _getConfig(t2) {
          return t2 = this._mergeConfigObj(t2), t2 = this._configAfterMerge(t2), this._typeCheckConfig(t2), t2;
        }
        _configAfterMerge(t2) {
          return t2;
        }
        _mergeConfigObj(t2, e2) {
          const i2 = R(e2) ? gt.getDataAttribute(e2, "config") : {};
          return { ...this.constructor.Default, ..."object" == typeof i2 ? i2 : {}, ...R(e2) ? gt.getDataAttributes(e2) : {}, ..."object" == typeof t2 ? t2 : {} };
        }
        _typeCheckConfig(t2, e2 = this.constructor.DefaultType) {
          for (const [n2, s2] of Object.entries(e2)) {
            const e3 = t2[n2], o2 = R(e3) ? "element" : null == (i2 = e3) ? `${i2}` : Object.prototype.toString.call(i2).match(/\s([a-z]+)/i)[1].toLowerCase();
            if (!new RegExp(s2).test(o2))
              throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n2}" provided type "${o2}" but expected type "${s2}".`);
          }
          var i2;
        }
      }
      let bt = class extends _t {
        constructor(t2, e2) {
          super(), (t2 = B(t2)) && (this._element = t2, this._config = this._getConfig(e2), P.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
          P.remove(this._element, this.constructor.DATA_KEY), ut.off(this._element, this.constructor.EVENT_KEY);
          for (const t2 of Object.getOwnPropertyNames(this))
            this[t2] = null;
        }
        _queueCallback(t2, e2, i2 = true) {
          X(t2, e2, i2);
        }
        _getConfig(t2) {
          return t2 = this._mergeConfigObj(t2, this._element), t2 = this._configAfterMerge(t2), this._typeCheckConfig(t2), t2;
        }
        static getInstance(t2) {
          return P.get(B(t2), this.DATA_KEY);
        }
        static getOrCreateInstance(t2, e2 = {}) {
          return this.getInstance(t2) || new this(t2, "object" == typeof e2 ? e2 : null);
        }
        static get VERSION() {
          return "5.3.3";
        }
        static get DATA_KEY() {
          return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
        static eventName(t2) {
          return `${t2}${this.EVENT_KEY}`;
        }
      };
      let vt = class t2 extends bt {
        static get NAME() {
          return "button";
        }
        toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this);
            "toggle" === e2 && i2[e2]();
          });
        }
      };
      const yt = (() => {
        const t2 = [];
        return { set(e2) {
          t2.push(e2);
        }, get: (e2) => t2.includes(e2) };
      })(), wt = { set(t2) {
        yt.set(t2);
      }, get: (t2) => yt.get(t2) }, Et = (t2) => {
        if (e2 = t2.NAME, !wt.get(e2)) {
          At(t2, true);
        }
        var e2;
      }, At = (t2, e2 = false) => {
        if (!t2 || wt.get(t2.NAME))
          return;
        e2 || wt.set(t2.NAME);
        const i2 = Ct[t2.NAME] || null, n2 = (null == i2 ? void 0 : i2.isToggler) || false;
        var s2;
        s2 = t2, p(() => {
          const t3 = f();
          if (t3) {
            const e3 = s2.NAME, i3 = t3.fn[e3];
            t3.fn[e3] = s2.jQueryInterface, t3.fn[e3].Constructor = s2, t3.fn[e3].noConflict = () => (t3.fn[e3] = i3, s2.jQueryInterface);
          }
        }), (null == i2 ? void 0 : i2.advanced) ? i2.advanced(t2, null == i2 ? void 0 : i2.selector) : n2 ? i2.callback(t2, null == i2 ? void 0 : i2.selector) : e2 || S.find(null == i2 ? void 0 : i2.selector).forEach((e3) => {
          let n3 = t2.getInstance(e3);
          n3 || (n3 = new t2(e3), (null == i2 ? void 0 : i2.onInit) && n3[i2.onInit]());
        });
      };
      let Ct;
      const Tt = "button", Ot = `mdb.${Tt}`, xt = `.${Ot}`, Lt = `click${xt}`, $t = "transitionend", Dt = "mouseenter", kt = "mouseleave", Nt = `hide${xt}`, Mt = `hidden${xt}`, St = `show${xt}`, It = `shown${xt}`, Pt = "active", jt = "fixed-action-btn";
      class Ht extends vt {
        constructor(t2) {
          super(t2), this._fn = {}, this._element && (s.setData(this._element, Ot, this), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor));
        }
        static get NAME() {
          return Tt;
        }
        static jQueryInterface(t2, e2) {
          return this.each(function() {
            let i2 = s.getData(this, Ot);
            const n2 = "object" == typeof t2 && t2;
            if ((i2 || !/dispose/.test(t2)) && (i2 || (i2 = new Ht(this, n2)), "string" == typeof t2)) {
              if (void 0 === i2[t2])
                throw new TypeError(`No method named "${t2}"`);
              i2[t2](e2);
            }
          });
        }
        get _actionButton() {
          return S.findOne(".fixed-action-btn:not(.smooth-scroll) > .btn-floating", this._element);
        }
        get _buttonListElements() {
          return S.find("ul .btn", this._element);
        }
        get _buttonList() {
          return S.findOne("ul", this._element);
        }
        get _isTouchDevice() {
          return "ontouchstart" in document.documentElement;
        }
        show() {
          M.hasClass(this._element, jt) && (D.off(this._buttonList, $t), D.trigger(this._element, St), this._bindListOpenTransitionEnd(), M.addStyle(this._element, { height: `${this._fullContainerHeight}px` }), this._toggleVisibility(true));
        }
        hide() {
          M.hasClass(this._element, jt) && (D.off(this._buttonList, $t), D.trigger(this._element, Nt), this._bindListHideTransitionEnd(), this._toggleVisibility(false));
        }
        dispose() {
          M.hasClass(this._element, jt) && (D.off(this._actionButton, Lt), this._actionButton.removeEventListener(Dt, this._fn.mouseenter), this._element.removeEventListener(kt, this._fn.mouseleave)), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        _init() {
          M.hasClass(this._element, jt) && (this._saveInitialHeights(), this._setInitialStyles(), this._bindInitialEvents());
        }
        _bindMouseEnter() {
          this._actionButton.addEventListener(Dt, this._fn.mouseenter = () => {
            this._isTouchDevice || this.show();
          });
        }
        _bindMouseLeave() {
          this._element.addEventListener(kt, this._fn.mouseleave = () => {
            this.hide();
          });
        }
        _bindClick() {
          D.on(this._actionButton, Lt, () => {
            M.hasClass(this._element, Pt) ? this.hide() : this.show();
          });
        }
        _bindListHideTransitionEnd() {
          D.on(this._buttonList, $t, (t2) => {
            "transform" === t2.propertyName && (D.off(this._buttonList, $t), this._element.style.height = `${this._initialContainerHeight}px`, D.trigger(this._element, Mt));
          });
        }
        _bindListOpenTransitionEnd() {
          D.on(this._buttonList, $t, (t2) => {
            "transform" === t2.propertyName && (D.off(this._buttonList, $t), D.trigger(this._element, It));
          });
        }
        _toggleVisibility(t2) {
          const e2 = t2 ? "addClass" : "removeClass", i2 = t2 ? "translate(0)" : `translateY(${this._fullContainerHeight}px)`;
          M.addStyle(this._buttonList, { transform: i2 }), this._buttonListElements && this._buttonListElements.forEach((t3) => M[e2](t3, "shown")), M[e2](this._element, Pt);
        }
        _getHeight(t2) {
          const e2 = window.getComputedStyle(t2);
          return parseFloat(e2.getPropertyValue("height"));
        }
        _saveInitialHeights() {
          this._initialContainerHeight = this._getHeight(this._element), this._initialListHeight = this._getHeight(this._buttonList), this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight;
        }
        _bindInitialEvents() {
          this._bindClick(), this._bindMouseEnter(), this._bindMouseLeave();
        }
        _setInitialStyles() {
          this._buttonList.style.marginBottom = `${this._initialContainerHeight}px`, this._buttonList.style.transform = `translateY(${this._fullContainerHeight}px)`, this._element.style.height = `${this._initialContainerHeight}px`;
        }
      }
      const zt = (t2) => {
        let e2 = t2.getAttribute("data-mdb-target");
        if (!e2 || "#" === e2) {
          let i2 = t2.getAttribute("href");
          if (!i2 || !i2.includes("#") && !i2.startsWith("."))
            return null;
          i2.includes("#") && !i2.startsWith("#") && (i2 = `#${i2.split("#")[1]}`), e2 = i2 && "#" !== i2 ? i2.trim() : null;
        }
        return e2 ? e2.split(",").map((t3) => H(t3)).join(",") : null;
      }, Rt = { find: (t2, e2 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e2, t2)), findOne: (t2, e2 = document.documentElement) => Element.prototype.querySelector.call(e2, t2), children: (t2, e2) => [].concat(...t2.children).filter((t3) => t3.matches(e2)), parents(t2, e2) {
        const i2 = [];
        let n2 = t2.parentNode.closest(e2);
        for (; n2; )
          i2.push(n2), n2 = n2.parentNode.closest(e2);
        return i2;
      }, prev(t2, e2) {
        let i2 = t2.previousElementSibling;
        for (; i2; ) {
          if (i2.matches(e2))
            return [i2];
          i2 = i2.previousElementSibling;
        }
        return [];
      }, next(t2, e2) {
        let i2 = t2.nextElementSibling;
        for (; i2; ) {
          if (i2.matches(e2))
            return [i2];
          i2 = i2.nextElementSibling;
        }
        return [];
      }, focusableChildren(t2) {
        const e2 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t3) => `${t3}:not([tabindex^="-"])`).join(",");
        return this.find(e2, t2).filter((t3) => !F(t3) && W(t3));
      }, getSelectorFromElement(t2) {
        const e2 = zt(t2);
        return e2 && Rt.findOne(e2) ? e2 : null;
      }, getElementFromSelector(t2) {
        const e2 = zt(t2);
        return e2 ? Rt.findOne(e2) : null;
      }, getMultipleElementsFromSelector(t2) {
        const e2 = zt(t2);
        return e2 ? Rt.find(e2) : [];
      } }, Bt = "backdrop", Wt = "show", Ft = `mousedown.bs.${Bt}`, qt = { className: "modal-backdrop", clickCallback: null, isAnimated: false, isVisible: true, rootElement: "body" }, Vt = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
      class Yt extends _t {
        constructor(t2) {
          super(), this._config = this._getConfig(t2), this._isAppended = false, this._element = null;
        }
        static get Default() {
          return qt;
        }
        static get DefaultType() {
          return Vt;
        }
        static get NAME() {
          return Bt;
        }
        show(t2) {
          if (!this._config.isVisible)
            return void K(t2);
          this._append();
          const e2 = this._getElement();
          this._config.isAnimated && Y(e2), e2.classList.add(Wt), this._emulateAnimation(() => {
            K(t2);
          });
        }
        hide(t2) {
          this._config.isVisible ? (this._getElement().classList.remove(Wt), this._emulateAnimation(() => {
            this.dispose(), K(t2);
          })) : K(t2);
        }
        dispose() {
          this._isAppended && (ut.off(this._element, Ft), this._element.remove(), this._isAppended = false);
        }
        _getElement() {
          if (!this._element) {
            const t2 = document.createElement("div");
            t2.className = this._config.className, this._config.isAnimated && t2.classList.add("fade"), this._element = t2;
          }
          return this._element;
        }
        _configAfterMerge(t2) {
          return t2.rootElement = B(t2.rootElement), t2;
        }
        _append() {
          if (this._isAppended)
            return;
          const t2 = this._getElement();
          this._config.rootElement.append(t2), ut.on(t2, Ft, () => {
            K(this._config.clickCallback);
          }), this._isAppended = true;
        }
        _emulateAnimation(t2) {
          X(t2, this._getElement(), this._config.isAnimated);
        }
      }
      const Ut = (t2, e2 = "hide") => {
        const i2 = `click.dismiss${t2.EVENT_KEY}`, n2 = t2.NAME;
        ut.on(document, i2, `[data-mdb-dismiss="${n2}"]`, function(i3) {
          if (["A", "AREA"].includes(this.tagName) && i3.preventDefault(), F(this))
            return;
          const s2 = Rt.getElementFromSelector(this) || this.closest(`.${n2}`);
          t2.getOrCreateInstance(s2)[e2]();
        });
      }, Kt = ".bs.focustrap", Xt = `focusin${Kt}`, Qt = `keydown.tab${Kt}`, Gt = "backward", Zt = { autofocus: true, trapElement: null }, Jt = { autofocus: "boolean", trapElement: "element" };
      class te extends _t {
        constructor(t2) {
          super(), this._config = this._getConfig(t2), this._isActive = false, this._lastTabNavDirection = null;
        }
        static get Default() {
          return Zt;
        }
        static get DefaultType() {
          return Jt;
        }
        static get NAME() {
          return "focustrap";
        }
        activate() {
          this._isActive || (this._config.autofocus && this._config.trapElement.focus(), ut.off(document, Kt), ut.on(document, Xt, (t2) => this._handleFocusin(t2)), ut.on(document, Qt, (t2) => this._handleKeydown(t2)), this._isActive = true);
        }
        deactivate() {
          this._isActive && (this._isActive = false, ut.off(document, Kt));
        }
        _handleFocusin(t2) {
          const { trapElement: e2 } = this._config;
          if (t2.target === document || t2.target === e2 || e2.contains(t2.target))
            return;
          const i2 = Rt.focusableChildren(e2);
          0 === i2.length ? e2.focus() : this._lastTabNavDirection === Gt ? i2[i2.length - 1].focus() : i2[0].focus();
        }
        _handleKeydown(t2) {
          "Tab" === t2.key && (this._lastTabNavDirection = t2.shiftKey ? Gt : "forward");
        }
      }
      const ee = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ie = ".sticky-top", ne = "padding-right", se = "margin-right";
      class oe {
        constructor() {
          this._element = document.body;
        }
        getWidth() {
          const t2 = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - t2);
        }
        hide() {
          const t2 = this.getWidth();
          this._disableOverFlow(), this._setElementAttributes(this._element, ne, (e2) => e2 + t2), this._setElementAttributes(ee, ne, (e2) => e2 + t2), this._setElementAttributes(ie, se, (e2) => e2 - t2);
        }
        reset() {
          this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, ne), this._resetElementAttributes(ee, ne), this._resetElementAttributes(ie, se);
        }
        isOverflowing() {
          return this.getWidth() > 0;
        }
        _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t2, e2, i2) {
          const n2 = this.getWidth();
          this._applyManipulationCallback(t2, (t3) => {
            if (t3 !== this._element && window.innerWidth > t3.clientWidth + n2)
              return;
            this._saveInitialAttribute(t3, e2);
            const s2 = window.getComputedStyle(t3).getPropertyValue(e2);
            t3.style.setProperty(e2, `${i2(Number.parseFloat(s2))}px`);
          });
        }
        _saveInitialAttribute(t2, e2) {
          const i2 = t2.style.getPropertyValue(e2);
          i2 && gt.setDataAttribute(t2, e2, i2);
        }
        _resetElementAttributes(t2, e2) {
          this._applyManipulationCallback(t2, (t3) => {
            const i2 = gt.getDataAttribute(t3, e2);
            null !== i2 ? (gt.removeDataAttribute(t3, e2), t3.style.setProperty(e2, i2)) : t3.style.removeProperty(e2);
          });
        }
        _applyManipulationCallback(t2, e2) {
          if (R(t2))
            e2(t2);
          else
            for (const i2 of Rt.find(t2, this._element))
              e2(i2);
        }
      }
      const re = ".bs.offcanvas", ae = "show", le = "showing", ce = "hiding", he = `show${re}`, de = `shown${re}`, ue = `hide${re}`, fe = `hidePrevented${re}`, pe = `hidden${re}`, me = `keydown.dismiss${re}`, ge = { backdrop: true, keyboard: true, scroll: false }, _e = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
      class be extends bt {
        constructor(t2, e2) {
          super(t2, e2), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get Default() {
          return ge;
        }
        static get DefaultType() {
          return _e;
        }
        static get NAME() {
          return "offcanvas";
        }
        toggle(t2) {
          return this._isShown ? this.hide() : this.show(t2);
        }
        show(t2) {
          if (this._isShown)
            return;
          if (ut.trigger(this._element, he, { relatedTarget: t2 }).defaultPrevented)
            return;
          this._isShown = true, this._backdrop.show(), this._config.scroll || new oe().hide(), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(le);
          this._queueCallback(() => {
            this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(ae), this._element.classList.remove(le), ut.trigger(this._element, de, { relatedTarget: t2 });
          }, this._element, true);
        }
        hide() {
          if (!this._isShown)
            return;
          if (ut.trigger(this._element, ue).defaultPrevented)
            return;
          this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.add(ce), this._backdrop.hide();
          this._queueCallback(() => {
            this._element.classList.remove(ae, ce), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new oe().reset(), ut.trigger(this._element, pe);
          }, this._element, true);
        }
        dispose() {
          this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _initializeBackDrop() {
          const t2 = Boolean(this._config.backdrop);
          return new Yt({ className: "offcanvas-backdrop", isVisible: t2, isAnimated: true, rootElement: this._element.parentNode, clickCallback: t2 ? () => {
            "static" !== this._config.backdrop ? this.hide() : ut.trigger(this._element, fe);
          } : null });
        }
        _initializeFocusTrap() {
          return new te({ trapElement: this._element });
        }
        _addEventListeners() {
          ut.on(this._element, me, (t2) => {
            "Escape" === t2.key && (this._config.keyboard ? this.hide() : ut.trigger(this._element, fe));
          });
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = be.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2)
                throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      const ve = ".bs.alert", ye = `close${ve}`, we = `closed${ve}`;
      let Ee = class t2 extends bt {
        static get NAME() {
          return "alert";
        }
        close() {
          if (ut.trigger(this._element, ye).defaultPrevented)
            return;
          this._element.classList.remove("show");
          const t3 = this._element.classList.contains("fade");
          this._queueCallback(() => this._destroyElement(), this._element, t3);
        }
        _destroyElement() {
          this._element.remove(), ut.trigger(this._element, we), this.dispose();
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2] || e2.startsWith("_") || "constructor" === e2)
                throw new TypeError(`No method named "${e2}"`);
              i2[e2](this);
            }
          });
        }
      };
      const Ae = "alert", Ce = [{ name: "close" }, { name: "closed" }];
      class Te extends Ee {
        constructor(t2, e2 = {}) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "close.bs.alert"), D.off(this._element, "closed.bs.alert"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return Ae;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, Ce, Ae);
        }
      }
      const Oe = ".bs.swipe", xe = `touchstart${Oe}`, Le = `touchmove${Oe}`, $e = `touchend${Oe}`, De = `pointerdown${Oe}`, ke = `pointerup${Oe}`, Ne = { endCallback: null, leftCallback: null, rightCallback: null }, Me = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
      class Se extends _t {
        constructor(t2, e2) {
          super(), this._element = t2, t2 && Se.isSupported() && (this._config = this._getConfig(e2), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
        }
        static get Default() {
          return Ne;
        }
        static get DefaultType() {
          return Me;
        }
        static get NAME() {
          return "swipe";
        }
        dispose() {
          ut.off(this._element, Oe);
        }
        _start(t2) {
          this._supportPointerEvents ? this._eventIsPointerPenTouch(t2) && (this._deltaX = t2.clientX) : this._deltaX = t2.touches[0].clientX;
        }
        _end(t2) {
          this._eventIsPointerPenTouch(t2) && (this._deltaX = t2.clientX - this._deltaX), this._handleSwipe(), K(this._config.endCallback);
        }
        _move(t2) {
          this._deltaX = t2.touches && t2.touches.length > 1 ? 0 : t2.touches[0].clientX - this._deltaX;
        }
        _handleSwipe() {
          const t2 = Math.abs(this._deltaX);
          if (t2 <= 40)
            return;
          const e2 = t2 / this._deltaX;
          this._deltaX = 0, e2 && K(e2 > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
        _initEvents() {
          this._supportPointerEvents ? (ut.on(this._element, De, (t2) => this._start(t2)), ut.on(this._element, ke, (t2) => this._end(t2)), this._element.classList.add("pointer-event")) : (ut.on(this._element, xe, (t2) => this._start(t2)), ut.on(this._element, Le, (t2) => this._move(t2)), ut.on(this._element, $e, (t2) => this._end(t2)));
        }
        _eventIsPointerPenTouch(t2) {
          return this._supportPointerEvents && ("pen" === t2.pointerType || "touch" === t2.pointerType);
        }
        static isSupported() {
          return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        }
      }
      const Ie = ".bs.carousel", Pe = "next", je = "prev", He = "left", ze = "right", Re = `slide${Ie}`, Be = `slid${Ie}`, We = `keydown${Ie}`, Fe = `mouseenter${Ie}`, qe = `mouseleave${Ie}`, Ve = `dragstart${Ie}`, Ye = "active", Ue = ".active", Ke = ".carousel-item", Xe = Ue + Ke, Qe = { ArrowLeft: ze, ArrowRight: He }, Ge = { interval: 5e3, keyboard: true, pause: "hover", ride: false, touch: true, wrap: true }, Ze = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
      let Je = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._interval = null, this._activeElement = null, this._isSliding = false, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Rt.findOne(".carousel-indicators", this._element), this._addEventListeners(), "carousel" === this._config.ride && this.cycle();
        }
        static get Default() {
          return Ge;
        }
        static get DefaultType() {
          return Ze;
        }
        static get NAME() {
          return "carousel";
        }
        next() {
          this._slide(Pe);
        }
        nextWhenVisible() {
          !document.hidden && W(this._element) && this.next();
        }
        prev() {
          this._slide(je);
        }
        pause() {
          this._isSliding && z(this._element), this._clearInterval();
        }
        cycle() {
          this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
        }
        _maybeEnableCycle() {
          this._config.ride && (this._isSliding ? ut.one(this._element, Be, () => this.cycle()) : this.cycle());
        }
        to(t3) {
          const e2 = this._getItems();
          if (t3 > e2.length - 1 || t3 < 0)
            return;
          if (this._isSliding)
            return void ut.one(this._element, Be, () => this.to(t3));
          const i2 = this._getItemIndex(this._getActive());
          if (i2 === t3)
            return;
          const n2 = t3 > i2 ? Pe : je;
          this._slide(n2, e2[t3]);
        }
        dispose() {
          this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
        }
        _configAfterMerge(t3) {
          return t3.defaultInterval = t3.interval, t3;
        }
        _addEventListeners() {
          this._config.keyboard && ut.on(this._element, We, (t3) => this._keydown(t3)), "hover" === this._config.pause && (ut.on(this._element, Fe, () => this.pause()), ut.on(this._element, qe, () => this._maybeEnableCycle())), this._config.touch && Se.isSupported() && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
          for (const e2 of Rt.find(".carousel-item img", this._element))
            ut.on(e2, Ve, (t4) => t4.preventDefault());
          const t3 = { leftCallback: () => this._slide(this._directionToOrder(He)), rightCallback: () => this._slide(this._directionToOrder(ze)), endCallback: () => {
            "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
          } };
          this._swipeHelper = new Se(this._element, t3);
        }
        _keydown(t3) {
          if (/input|textarea/i.test(t3.target.tagName))
            return;
          const e2 = Qe[t3.key];
          e2 && (t3.preventDefault(), this._slide(this._directionToOrder(e2)));
        }
        _getItemIndex(t3) {
          return this._getItems().indexOf(t3);
        }
        _setActiveIndicatorElement(t3) {
          if (!this._indicatorsElement)
            return;
          const e2 = Rt.findOne(Ue, this._indicatorsElement);
          e2.classList.remove(Ye), e2.removeAttribute("aria-current");
          const i2 = Rt.findOne(`[data-mdb-slide-to="${t3}"]`, this._indicatorsElement);
          i2 && (i2.classList.add(Ye), i2.setAttribute("aria-current", "true"));
        }
        _updateInterval() {
          const t3 = this._activeElement || this._getActive();
          if (!t3)
            return;
          const e2 = Number.parseInt(t3.getAttribute("data-mdb-interval"), 10);
          this._config.interval = e2 || this._config.defaultInterval;
        }
        _slide(t3, e2 = null) {
          if (this._isSliding)
            return;
          const i2 = this._getActive(), n2 = t3 === Pe, s2 = e2 || Q(this._getItems(), i2, n2, this._config.wrap);
          if (s2 === i2)
            return;
          const o2 = this._getItemIndex(s2), r2 = (e3) => ut.trigger(this._element, e3, { relatedTarget: s2, direction: this._orderToDirection(t3), from: this._getItemIndex(i2), to: o2 });
          if (r2(Re).defaultPrevented)
            return;
          if (!i2 || !s2)
            return;
          const a2 = Boolean(this._interval);
          this.pause(), this._isSliding = true, this._setActiveIndicatorElement(o2), this._activeElement = s2;
          const l2 = n2 ? "carousel-item-start" : "carousel-item-end", c2 = n2 ? "carousel-item-next" : "carousel-item-prev";
          s2.classList.add(c2), Y(s2), i2.classList.add(l2), s2.classList.add(l2);
          this._queueCallback(() => {
            s2.classList.remove(l2, c2), s2.classList.add(Ye), i2.classList.remove(Ye, c2, l2), this._isSliding = false, r2(Be);
          }, i2, this._isAnimated()), a2 && this.cycle();
        }
        _isAnimated() {
          return this._element.classList.contains("slide");
        }
        _getActive() {
          return Rt.findOne(Xe, this._element);
        }
        _getItems() {
          return Rt.find(Ke, this._element);
        }
        _clearInterval() {
          this._interval && (clearInterval(this._interval), this._interval = null);
        }
        _directionToOrder(t3) {
          return U() ? t3 === He ? je : Pe : t3 === He ? Pe : je;
        }
        _orderToDirection(t3) {
          return U() ? t3 === je ? He : ze : t3 === je ? ze : He;
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("number" != typeof e2) {
              if ("string" == typeof e2) {
                if (void 0 === i2[e2] || e2.startsWith("_") || "constructor" === e2)
                  throw new TypeError(`No method named "${e2}"`);
                i2[e2]();
              }
            } else
              i2.to(e2);
          });
        }
      };
      const ti = "carousel", ei = [{ name: "slide", parametersToCopy: ["relatedTarget", "direction", "from", "to"] }, { name: "slid", parametersToCopy: ["relatedTarget", "direction", "from", "to"] }];
      class ii extends Je {
        constructor(t2, e2) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "slide.bs.carousel"), D.off(this._element, "slid.bs.carousel"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return ti;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, ei, ti);
        }
      }
      const ni = ".bs.modal", si = `hide${ni}`, oi = `hidePrevented${ni}`, ri = `hidden${ni}`, ai = `show${ni}`, li = `shown${ni}`, ci = `resize${ni}`, hi = `click.dismiss${ni}`, di = `mousedown.dismiss${ni}`, ui = `keydown.dismiss${ni}`, fi = "modal-open", pi = "show", mi = "modal-static", gi = { backdrop: true, focus: true, keyboard: true }, _i = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
      let bi = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._dialog = Rt.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._isTransitioning = false, this._scrollBar = new oe(), this._addEventListeners();
        }
        static get Default() {
          return gi;
        }
        static get DefaultType() {
          return _i;
        }
        static get NAME() {
          return "modal";
        }
        toggle(t3) {
          return this._isShown ? this.hide() : this.show(t3);
        }
        show(t3) {
          if (this._isShown || this._isTransitioning)
            return;
          ut.trigger(this._element, ai, { relatedTarget: t3 }).defaultPrevented || (this._isShown = true, this._isTransitioning = true, this._scrollBar.hide(), document.body.classList.add(fi), this._adjustDialog(), this._backdrop.show(() => this._showElement(t3)));
        }
        hide() {
          if (!this._isShown || this._isTransitioning)
            return;
          ut.trigger(this._element, si).defaultPrevented || (this._isShown = false, this._isTransitioning = true, this._focustrap.deactivate(), this._element.classList.remove(pi), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()));
        }
        dispose() {
          ut.off(window, ni), ut.off(this._dialog, ni), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
          this._adjustDialog();
        }
        _initializeBackDrop() {
          return new Yt({ isVisible: Boolean(this._config.backdrop) && Boolean(!this._config.modalNonInvasive), isAnimated: this._isAnimated() });
        }
        _initializeFocusTrap() {
          return new te({ trapElement: this._element });
        }
        _showElement(t3) {
          document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
          const e2 = Rt.findOne(".modal-body", this._dialog);
          e2 && (e2.scrollTop = 0), Y(this._element), this._element.classList.add(pi);
          this._queueCallback(() => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = false, ut.trigger(this._element, li, { relatedTarget: t3 });
          }, this._dialog, this._isAnimated());
        }
        _addEventListeners() {
          ut.on(this._element, ui, (t3) => {
            "Escape" === t3.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
          }), ut.on(window, ci, () => {
            this._isShown && !this._isTransitioning && this._adjustDialog();
          }), ut.on(this._element, di, (t3) => {
            ut.one(this._element, hi, (e2) => {
              this._element === t3.target && this._element === e2.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
            });
          });
        }
        _hideModal() {
          this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
            document.body.classList.remove(fi), this._resetAdjustments(), this._scrollBar.reset(), ut.trigger(this._element, ri);
          });
        }
        _isAnimated() {
          return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
          if (ut.trigger(this._element, oi).defaultPrevented)
            return;
          const t3 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._element.style.overflowY;
          "hidden" === e2 || this._element.classList.contains(mi) || (t3 || (this._element.style.overflowY = "hidden"), this._element.classList.add(mi), this._queueCallback(() => {
            this._element.classList.remove(mi), this._queueCallback(() => {
              this._element.style.overflowY = e2;
            }, this._dialog);
          }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
          const t3 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._scrollBar.getWidth(), i2 = e2 > 0;
          if (i2 && !t3) {
            const t4 = U() ? "paddingLeft" : "paddingRight";
            this._element.style[t4] = `${e2}px`;
          }
          if (!i2 && t3) {
            const t4 = U() ? "paddingRight" : "paddingLeft";
            this._element.style[t4] = `${e2}px`;
          }
        }
        _resetAdjustments() {
          this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(e2, i2) {
          return this.each(function() {
            const n2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === n2[e2])
                throw new TypeError(`No method named "${e2}"`);
              n2[e2](i2);
            }
          });
        }
      };
      const vi = "modal", yi = [{ name: "show", parametersToCopy: ["relatedTarget"] }, { name: "shown", parametersToCopy: ["relatedTarget"] }, { name: "hide" }, { name: "hidePrevented" }, { name: "hidden" }];
      class wi extends bi {
        constructor(t2, e2) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "show.bs.modal"), D.off(this._element, "shown.bs.modal"), D.off(this._element, "hide.bs.modal"), D.off(this._element, "hidden.bs.modal"), D.off(this._element, "hidePrevented.bs.modal"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return vi;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, yi, vi);
        }
      }
      var Ei = "top", Ai = "bottom", Ci = "right", Ti = "left", Oi = "auto", xi = [Ei, Ai, Ci, Ti], Li = "start", $i = "end", Di = "clippingParents", ki = "viewport", Ni = "popper", Mi = "reference", Si = xi.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + Li, e2 + "-" + $i]);
      }, []), Ii = [].concat(xi, [Oi]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + Li, e2 + "-" + $i]);
      }, []), Pi = "beforeRead", ji = "read", Hi = "afterRead", zi = "beforeMain", Ri = "main", Bi = "afterMain", Wi = "beforeWrite", Fi = "write", qi = "afterWrite", Vi = [Pi, ji, Hi, zi, Ri, Bi, Wi, Fi, qi];
      function Yi(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function Ui(t2) {
        if (null == t2)
          return window;
        if ("[object Window]" !== t2.toString()) {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function Ki(t2) {
        return t2 instanceof Ui(t2).Element || t2 instanceof Element;
      }
      function Xi(t2) {
        return t2 instanceof Ui(t2).HTMLElement || t2 instanceof HTMLElement;
      }
      function Qi(t2) {
        return "undefined" != typeof ShadowRoot && (t2 instanceof Ui(t2).ShadowRoot || t2 instanceof ShadowRoot);
      }
      const Gi = { name: "applyStyles", enabled: true, phase: "write", fn: function(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(t3) {
          var i2 = e2.styles[t3] || {}, n2 = e2.attributes[t3] || {}, s2 = e2.elements[t3];
          Xi(s2) && Yi(s2) && (Object.assign(s2.style, i2), Object.keys(n2).forEach(function(t4) {
            var e3 = n2[t4];
            false === e3 ? s2.removeAttribute(t4) : s2.setAttribute(t4, true === e3 ? "" : e3);
          }));
        });
      }, effect: function(t2) {
        var e2 = t2.state, i2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, i2.popper), e2.styles = i2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, i2.arrow), function() {
          Object.keys(e2.elements).forEach(function(t3) {
            var n2 = e2.elements[t3], s2 = e2.attributes[t3] || {}, o2 = Object.keys(e2.styles.hasOwnProperty(t3) ? e2.styles[t3] : i2[t3]).reduce(function(t4, e3) {
              return t4[e3] = "", t4;
            }, {});
            Xi(n2) && Yi(n2) && (Object.assign(n2.style, o2), Object.keys(s2).forEach(function(t4) {
              n2.removeAttribute(t4);
            }));
          });
        };
      }, requires: ["computeStyles"] };
      function Zi(t2) {
        return t2.split("-")[0];
      }
      var Ji = Math.max, tn = Math.min, en = Math.round;
      function nn() {
        var t2 = navigator.userAgentData;
        return null != t2 && t2.brands && Array.isArray(t2.brands) ? t2.brands.map(function(t3) {
          return t3.brand + "/" + t3.version;
        }).join(" ") : navigator.userAgent;
      }
      function sn() {
        return !/^((?!chrome|android).)*safari/i.test(nn());
      }
      function on(t2, e2, i2) {
        void 0 === e2 && (e2 = false), void 0 === i2 && (i2 = false);
        var n2 = t2.getBoundingClientRect(), s2 = 1, o2 = 1;
        e2 && Xi(t2) && (s2 = t2.offsetWidth > 0 && en(n2.width) / t2.offsetWidth || 1, o2 = t2.offsetHeight > 0 && en(n2.height) / t2.offsetHeight || 1);
        var r2 = (Ki(t2) ? Ui(t2) : window).visualViewport, a2 = !sn() && i2, l2 = (n2.left + (a2 && r2 ? r2.offsetLeft : 0)) / s2, c2 = (n2.top + (a2 && r2 ? r2.offsetTop : 0)) / o2, h2 = n2.width / s2, d2 = n2.height / o2;
        return { width: h2, height: d2, top: c2, right: l2 + h2, bottom: c2 + d2, left: l2, x: l2, y: c2 };
      }
      function rn(t2) {
        var e2 = on(t2), i2 = t2.offsetWidth, n2 = t2.offsetHeight;
        return Math.abs(e2.width - i2) <= 1 && (i2 = e2.width), Math.abs(e2.height - n2) <= 1 && (n2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: i2, height: n2 };
      }
      function an(t2, e2) {
        var i2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2))
          return true;
        if (i2 && Qi(i2)) {
          var n2 = e2;
          do {
            if (n2 && t2.isSameNode(n2))
              return true;
            n2 = n2.parentNode || n2.host;
          } while (n2);
        }
        return false;
      }
      function ln(t2) {
        return Ui(t2).getComputedStyle(t2);
      }
      function cn(t2) {
        return ["table", "td", "th"].indexOf(Yi(t2)) >= 0;
      }
      function hn(t2) {
        return ((Ki(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function dn(t2) {
        return "html" === Yi(t2) ? t2 : t2.assignedSlot || t2.parentNode || (Qi(t2) ? t2.host : null) || hn(t2);
      }
      function un(t2) {
        return Xi(t2) && "fixed" !== ln(t2).position ? t2.offsetParent : null;
      }
      function fn(t2) {
        for (var e2 = Ui(t2), i2 = un(t2); i2 && cn(i2) && "static" === ln(i2).position; )
          i2 = un(i2);
        return i2 && ("html" === Yi(i2) || "body" === Yi(i2) && "static" === ln(i2).position) ? e2 : i2 || function(t3) {
          var e3 = /firefox/i.test(nn());
          if (/Trident/i.test(nn()) && Xi(t3) && "fixed" === ln(t3).position)
            return null;
          var i3 = dn(t3);
          for (Qi(i3) && (i3 = i3.host); Xi(i3) && ["html", "body"].indexOf(Yi(i3)) < 0; ) {
            var n2 = ln(i3);
            if ("none" !== n2.transform || "none" !== n2.perspective || "paint" === n2.contain || -1 !== ["transform", "perspective"].indexOf(n2.willChange) || e3 && "filter" === n2.willChange || e3 && n2.filter && "none" !== n2.filter)
              return i3;
            i3 = i3.parentNode;
          }
          return null;
        }(t2) || e2;
      }
      function pn(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function mn(t2, e2, i2) {
        return Ji(t2, tn(e2, i2));
      }
      function gn(t2) {
        return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t2);
      }
      function _n(t2, e2) {
        return e2.reduce(function(e3, i2) {
          return e3[i2] = t2, e3;
        }, {});
      }
      const bn = { name: "arrow", enabled: true, phase: "main", fn: function(t2) {
        var e2, i2 = t2.state, n2 = t2.name, s2 = t2.options, o2 = i2.elements.arrow, r2 = i2.modifiersData.popperOffsets, a2 = Zi(i2.placement), l2 = pn(a2), c2 = [Ti, Ci].indexOf(a2) >= 0 ? "height" : "width";
        if (o2 && r2) {
          var h2 = function(t3, e3) {
            return gn("number" != typeof (t3 = "function" == typeof t3 ? t3(Object.assign({}, e3.rects, { placement: e3.placement })) : t3) ? t3 : _n(t3, xi));
          }(s2.padding, i2), d2 = rn(o2), u2 = "y" === l2 ? Ei : Ti, f2 = "y" === l2 ? Ai : Ci, p2 = i2.rects.reference[c2] + i2.rects.reference[l2] - r2[l2] - i2.rects.popper[c2], m2 = r2[l2] - i2.rects.reference[l2], g2 = fn(o2), _2 = g2 ? "y" === l2 ? g2.clientHeight || 0 : g2.clientWidth || 0 : 0, b2 = p2 / 2 - m2 / 2, v2 = h2[u2], y2 = _2 - d2[c2] - h2[f2], w2 = _2 / 2 - d2[c2] / 2 + b2, E2 = mn(v2, w2, y2), A2 = l2;
          i2.modifiersData[n2] = ((e2 = {})[A2] = E2, e2.centerOffset = E2 - w2, e2);
        }
      }, effect: function(t2) {
        var e2 = t2.state, i2 = t2.options.element, n2 = void 0 === i2 ? "[data-popper-arrow]" : i2;
        null != n2 && ("string" != typeof n2 || (n2 = e2.elements.popper.querySelector(n2))) && an(e2.elements.popper, n2) && (e2.elements.arrow = n2);
      }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function vn(t2) {
        return t2.split("-")[1];
      }
      var yn = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function wn(t2) {
        var e2, i2 = t2.popper, n2 = t2.popperRect, s2 = t2.placement, o2 = t2.variation, r2 = t2.offsets, a2 = t2.position, l2 = t2.gpuAcceleration, c2 = t2.adaptive, h2 = t2.roundOffsets, d2 = t2.isFixed, u2 = r2.x, f2 = void 0 === u2 ? 0 : u2, p2 = r2.y, m2 = void 0 === p2 ? 0 : p2, g2 = "function" == typeof h2 ? h2({ x: f2, y: m2 }) : { x: f2, y: m2 };
        f2 = g2.x, m2 = g2.y;
        var _2 = r2.hasOwnProperty("x"), b2 = r2.hasOwnProperty("y"), v2 = Ti, y2 = Ei, w2 = window;
        if (c2) {
          var E2 = fn(i2), A2 = "clientHeight", C2 = "clientWidth";
          if (E2 === Ui(i2) && "static" !== ln(E2 = hn(i2)).position && "absolute" === a2 && (A2 = "scrollHeight", C2 = "scrollWidth"), s2 === Ei || (s2 === Ti || s2 === Ci) && o2 === $i)
            y2 = Ai, m2 -= (d2 && E2 === w2 && w2.visualViewport ? w2.visualViewport.height : E2[A2]) - n2.height, m2 *= l2 ? 1 : -1;
          if (s2 === Ti || (s2 === Ei || s2 === Ai) && o2 === $i)
            v2 = Ci, f2 -= (d2 && E2 === w2 && w2.visualViewport ? w2.visualViewport.width : E2[C2]) - n2.width, f2 *= l2 ? 1 : -1;
        }
        var T2, O2 = Object.assign({ position: a2 }, c2 && yn), x2 = true === h2 ? function(t3, e3) {
          var i3 = t3.x, n3 = t3.y, s3 = e3.devicePixelRatio || 1;
          return { x: en(i3 * s3) / s3 || 0, y: en(n3 * s3) / s3 || 0 };
        }({ x: f2, y: m2 }, Ui(i2)) : { x: f2, y: m2 };
        return f2 = x2.x, m2 = x2.y, l2 ? Object.assign({}, O2, ((T2 = {})[y2] = b2 ? "0" : "", T2[v2] = _2 ? "0" : "", T2.transform = (w2.devicePixelRatio || 1) <= 1 ? "translate(" + f2 + "px, " + m2 + "px)" : "translate3d(" + f2 + "px, " + m2 + "px, 0)", T2)) : Object.assign({}, O2, ((e2 = {})[y2] = b2 ? m2 + "px" : "", e2[v2] = _2 ? f2 + "px" : "", e2.transform = "", e2));
      }
      const En = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, n2 = i2.gpuAcceleration, s2 = void 0 === n2 || n2, o2 = i2.adaptive, r2 = void 0 === o2 || o2, a2 = i2.roundOffsets, l2 = void 0 === a2 || a2, c2 = { placement: Zi(e2.placement), variation: vn(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: s2, isFixed: "fixed" === e2.options.strategy };
        null != e2.modifiersData.popperOffsets && (e2.styles.popper = Object.assign({}, e2.styles.popper, wn(Object.assign({}, c2, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: r2, roundOffsets: l2 })))), null != e2.modifiersData.arrow && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, wn(Object.assign({}, c2, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l2 })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }, data: {} };
      var An = { passive: true };
      const Cn = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: function(t2) {
        var e2 = t2.state, i2 = t2.instance, n2 = t2.options, s2 = n2.scroll, o2 = void 0 === s2 || s2, r2 = n2.resize, a2 = void 0 === r2 || r2, l2 = Ui(e2.elements.popper), c2 = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return o2 && c2.forEach(function(t3) {
          t3.addEventListener("scroll", i2.update, An);
        }), a2 && l2.addEventListener("resize", i2.update, An), function() {
          o2 && c2.forEach(function(t3) {
            t3.removeEventListener("scroll", i2.update, An);
          }), a2 && l2.removeEventListener("resize", i2.update, An);
        };
      }, data: {} };
      var Tn = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function On(t2) {
        return t2.replace(/left|right|bottom|top/g, function(t3) {
          return Tn[t3];
        });
      }
      var xn = { start: "end", end: "start" };
      function Ln(t2) {
        return t2.replace(/start|end/g, function(t3) {
          return xn[t3];
        });
      }
      function $n(t2) {
        var e2 = Ui(t2);
        return { scrollLeft: e2.pageXOffset, scrollTop: e2.pageYOffset };
      }
      function Dn(t2) {
        return on(hn(t2)).left + $n(t2).scrollLeft;
      }
      function kn(t2) {
        var e2 = ln(t2), i2 = e2.overflow, n2 = e2.overflowX, s2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(i2 + s2 + n2);
      }
      function Nn(t2) {
        return ["html", "body", "#document"].indexOf(Yi(t2)) >= 0 ? t2.ownerDocument.body : Xi(t2) && kn(t2) ? t2 : Nn(dn(t2));
      }
      function Mn(t2, e2) {
        var i2;
        void 0 === e2 && (e2 = []);
        var n2 = Nn(t2), s2 = n2 === (null == (i2 = t2.ownerDocument) ? void 0 : i2.body), o2 = Ui(n2), r2 = s2 ? [o2].concat(o2.visualViewport || [], kn(n2) ? n2 : []) : n2, a2 = e2.concat(r2);
        return s2 ? a2 : a2.concat(Mn(dn(r2)));
      }
      function Sn(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function In(t2, e2, i2) {
        return e2 === ki ? Sn(function(t3, e3) {
          var i3 = Ui(t3), n2 = hn(t3), s2 = i3.visualViewport, o2 = n2.clientWidth, r2 = n2.clientHeight, a2 = 0, l2 = 0;
          if (s2) {
            o2 = s2.width, r2 = s2.height;
            var c2 = sn();
            (c2 || !c2 && "fixed" === e3) && (a2 = s2.offsetLeft, l2 = s2.offsetTop);
          }
          return { width: o2, height: r2, x: a2 + Dn(t3), y: l2 };
        }(t2, i2)) : Ki(e2) ? function(t3, e3) {
          var i3 = on(t3, false, "fixed" === e3);
          return i3.top = i3.top + t3.clientTop, i3.left = i3.left + t3.clientLeft, i3.bottom = i3.top + t3.clientHeight, i3.right = i3.left + t3.clientWidth, i3.width = t3.clientWidth, i3.height = t3.clientHeight, i3.x = i3.left, i3.y = i3.top, i3;
        }(e2, i2) : Sn(function(t3) {
          var e3, i3 = hn(t3), n2 = $n(t3), s2 = null == (e3 = t3.ownerDocument) ? void 0 : e3.body, o2 = Ji(i3.scrollWidth, i3.clientWidth, s2 ? s2.scrollWidth : 0, s2 ? s2.clientWidth : 0), r2 = Ji(i3.scrollHeight, i3.clientHeight, s2 ? s2.scrollHeight : 0, s2 ? s2.clientHeight : 0), a2 = -n2.scrollLeft + Dn(t3), l2 = -n2.scrollTop;
          return "rtl" === ln(s2 || i3).direction && (a2 += Ji(i3.clientWidth, s2 ? s2.clientWidth : 0) - o2), { width: o2, height: r2, x: a2, y: l2 };
        }(hn(t2)));
      }
      function Pn(t2, e2, i2, n2) {
        var s2 = "clippingParents" === e2 ? function(t3) {
          var e3 = Mn(dn(t3)), i3 = ["absolute", "fixed"].indexOf(ln(t3).position) >= 0 && Xi(t3) ? fn(t3) : t3;
          return Ki(i3) ? e3.filter(function(t4) {
            return Ki(t4) && an(t4, i3) && "body" !== Yi(t4);
          }) : [];
        }(t2) : [].concat(e2), o2 = [].concat(s2, [i2]), r2 = o2[0], a2 = o2.reduce(function(e3, i3) {
          var s3 = In(t2, i3, n2);
          return e3.top = Ji(s3.top, e3.top), e3.right = tn(s3.right, e3.right), e3.bottom = tn(s3.bottom, e3.bottom), e3.left = Ji(s3.left, e3.left), e3;
        }, In(t2, r2, n2));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function jn(t2) {
        var e2, i2 = t2.reference, n2 = t2.element, s2 = t2.placement, o2 = s2 ? Zi(s2) : null, r2 = s2 ? vn(s2) : null, a2 = i2.x + i2.width / 2 - n2.width / 2, l2 = i2.y + i2.height / 2 - n2.height / 2;
        switch (o2) {
          case Ei:
            e2 = { x: a2, y: i2.y - n2.height };
            break;
          case Ai:
            e2 = { x: a2, y: i2.y + i2.height };
            break;
          case Ci:
            e2 = { x: i2.x + i2.width, y: l2 };
            break;
          case Ti:
            e2 = { x: i2.x - n2.width, y: l2 };
            break;
          default:
            e2 = { x: i2.x, y: i2.y };
        }
        var c2 = o2 ? pn(o2) : null;
        if (null != c2) {
          var h2 = "y" === c2 ? "height" : "width";
          switch (r2) {
            case Li:
              e2[c2] = e2[c2] - (i2[h2] / 2 - n2[h2] / 2);
              break;
            case $i:
              e2[c2] = e2[c2] + (i2[h2] / 2 - n2[h2] / 2);
          }
        }
        return e2;
      }
      function Hn(t2, e2) {
        void 0 === e2 && (e2 = {});
        var i2 = e2, n2 = i2.placement, s2 = void 0 === n2 ? t2.placement : n2, o2 = i2.strategy, r2 = void 0 === o2 ? t2.strategy : o2, a2 = i2.boundary, l2 = void 0 === a2 ? Di : a2, c2 = i2.rootBoundary, h2 = void 0 === c2 ? ki : c2, d2 = i2.elementContext, u2 = void 0 === d2 ? Ni : d2, f2 = i2.altBoundary, p2 = void 0 !== f2 && f2, m2 = i2.padding, g2 = void 0 === m2 ? 0 : m2, _2 = gn("number" != typeof g2 ? g2 : _n(g2, xi)), b2 = u2 === Ni ? Mi : Ni, v2 = t2.rects.popper, y2 = t2.elements[p2 ? b2 : u2], w2 = Pn(Ki(y2) ? y2 : y2.contextElement || hn(t2.elements.popper), l2, h2, r2), E2 = on(t2.elements.reference), A2 = jn({ reference: E2, element: v2, strategy: "absolute", placement: s2 }), C2 = Sn(Object.assign({}, v2, A2)), T2 = u2 === Ni ? C2 : E2, O2 = { top: w2.top - T2.top + _2.top, bottom: T2.bottom - w2.bottom + _2.bottom, left: w2.left - T2.left + _2.left, right: T2.right - w2.right + _2.right }, x2 = t2.modifiersData.offset;
        if (u2 === Ni && x2) {
          var L2 = x2[s2];
          Object.keys(O2).forEach(function(t3) {
            var e3 = [Ci, Ai].indexOf(t3) >= 0 ? 1 : -1, i3 = [Ei, Ai].indexOf(t3) >= 0 ? "y" : "x";
            O2[t3] += L2[i3] * e3;
          });
        }
        return O2;
      }
      const zn = { name: "flip", enabled: true, phase: "main", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, n2 = t2.name;
        if (!e2.modifiersData[n2]._skip) {
          for (var s2 = i2.mainAxis, o2 = void 0 === s2 || s2, r2 = i2.altAxis, a2 = void 0 === r2 || r2, l2 = i2.fallbackPlacements, c2 = i2.padding, h2 = i2.boundary, d2 = i2.rootBoundary, u2 = i2.altBoundary, f2 = i2.flipVariations, p2 = void 0 === f2 || f2, m2 = i2.allowedAutoPlacements, g2 = e2.options.placement, _2 = Zi(g2), b2 = l2 || (_2 === g2 || !p2 ? [On(g2)] : function(t3) {
            if (Zi(t3) === Oi)
              return [];
            var e3 = On(t3);
            return [Ln(t3), e3, Ln(e3)];
          }(g2)), v2 = [g2].concat(b2).reduce(function(t3, i3) {
            return t3.concat(Zi(i3) === Oi ? function(t4, e3) {
              void 0 === e3 && (e3 = {});
              var i4 = e3, n3 = i4.placement, s3 = i4.boundary, o3 = i4.rootBoundary, r3 = i4.padding, a3 = i4.flipVariations, l3 = i4.allowedAutoPlacements, c3 = void 0 === l3 ? Ii : l3, h3 = vn(n3), d3 = h3 ? a3 ? Si : Si.filter(function(t5) {
                return vn(t5) === h3;
              }) : xi, u3 = d3.filter(function(t5) {
                return c3.indexOf(t5) >= 0;
              });
              0 === u3.length && (u3 = d3);
              var f3 = u3.reduce(function(e4, i5) {
                return e4[i5] = Hn(t4, { placement: i5, boundary: s3, rootBoundary: o3, padding: r3 })[Zi(i5)], e4;
              }, {});
              return Object.keys(f3).sort(function(t5, e4) {
                return f3[t5] - f3[e4];
              });
            }(e2, { placement: i3, boundary: h2, rootBoundary: d2, padding: c2, flipVariations: p2, allowedAutoPlacements: m2 }) : i3);
          }, []), y2 = e2.rects.reference, w2 = e2.rects.popper, E2 = /* @__PURE__ */ new Map(), A2 = true, C2 = v2[0], T2 = 0; T2 < v2.length; T2++) {
            var O2 = v2[T2], x2 = Zi(O2), L2 = vn(O2) === Li, $2 = [Ei, Ai].indexOf(x2) >= 0, D2 = $2 ? "width" : "height", k2 = Hn(e2, { placement: O2, boundary: h2, rootBoundary: d2, altBoundary: u2, padding: c2 }), N2 = $2 ? L2 ? Ci : Ti : L2 ? Ai : Ei;
            y2[D2] > w2[D2] && (N2 = On(N2));
            var M2 = On(N2), S2 = [];
            if (o2 && S2.push(k2[x2] <= 0), a2 && S2.push(k2[N2] <= 0, k2[M2] <= 0), S2.every(function(t3) {
              return t3;
            })) {
              C2 = O2, A2 = false;
              break;
            }
            E2.set(O2, S2);
          }
          if (A2)
            for (var I2 = function(t3) {
              var e3 = v2.find(function(e4) {
                var i3 = E2.get(e4);
                if (i3)
                  return i3.slice(0, t3).every(function(t4) {
                    return t4;
                  });
              });
              if (e3)
                return C2 = e3, "break";
            }, P2 = p2 ? 3 : 1; P2 > 0; P2--) {
              if ("break" === I2(P2))
                break;
            }
          e2.placement !== C2 && (e2.modifiersData[n2]._skip = true, e2.placement = C2, e2.reset = true);
        }
      }, requiresIfExists: ["offset"], data: { _skip: false } };
      function Rn(t2, e2, i2) {
        return void 0 === i2 && (i2 = { x: 0, y: 0 }), { top: t2.top - e2.height - i2.y, right: t2.right - e2.width + i2.x, bottom: t2.bottom - e2.height + i2.y, left: t2.left - e2.width - i2.x };
      }
      function Bn(t2) {
        return [Ei, Ci, Ai, Ti].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      const Wn = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(t2) {
        var e2 = t2.state, i2 = t2.name, n2 = e2.rects.reference, s2 = e2.rects.popper, o2 = e2.modifiersData.preventOverflow, r2 = Hn(e2, { elementContext: "reference" }), a2 = Hn(e2, { altBoundary: true }), l2 = Rn(r2, n2), c2 = Rn(a2, s2, o2), h2 = Bn(l2), d2 = Bn(c2);
        e2.modifiersData[i2] = { referenceClippingOffsets: l2, popperEscapeOffsets: c2, isReferenceHidden: h2, hasPopperEscaped: d2 }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": h2, "data-popper-escaped": d2 });
      } };
      const Fn = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, n2 = t2.name, s2 = i2.offset, o2 = void 0 === s2 ? [0, 0] : s2, r2 = Ii.reduce(function(t3, i3) {
          return t3[i3] = function(t4, e3, i4) {
            var n3 = Zi(t4), s3 = [Ti, Ei].indexOf(n3) >= 0 ? -1 : 1, o3 = "function" == typeof i4 ? i4(Object.assign({}, e3, { placement: t4 })) : i4, r3 = o3[0], a3 = o3[1];
            return r3 = r3 || 0, a3 = (a3 || 0) * s3, [Ti, Ci].indexOf(n3) >= 0 ? { x: a3, y: r3 } : { x: r3, y: a3 };
          }(i3, e2.rects, o2), t3;
        }, {}), a2 = r2[e2.placement], l2 = a2.x, c2 = a2.y;
        null != e2.modifiersData.popperOffsets && (e2.modifiersData.popperOffsets.x += l2, e2.modifiersData.popperOffsets.y += c2), e2.modifiersData[n2] = r2;
      } };
      const qn = { name: "popperOffsets", enabled: true, phase: "read", fn: function(t2) {
        var e2 = t2.state, i2 = t2.name;
        e2.modifiersData[i2] = jn({ reference: e2.rects.reference, element: e2.rects.popper, strategy: "absolute", placement: e2.placement });
      }, data: {} };
      const Vn = { name: "preventOverflow", enabled: true, phase: "main", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, n2 = t2.name, s2 = i2.mainAxis, o2 = void 0 === s2 || s2, r2 = i2.altAxis, a2 = void 0 !== r2 && r2, l2 = i2.boundary, c2 = i2.rootBoundary, h2 = i2.altBoundary, d2 = i2.padding, u2 = i2.tether, f2 = void 0 === u2 || u2, p2 = i2.tetherOffset, m2 = void 0 === p2 ? 0 : p2, g2 = Hn(e2, { boundary: l2, rootBoundary: c2, padding: d2, altBoundary: h2 }), _2 = Zi(e2.placement), b2 = vn(e2.placement), v2 = !b2, y2 = pn(_2), w2 = "x" === y2 ? "y" : "x", E2 = e2.modifiersData.popperOffsets, A2 = e2.rects.reference, C2 = e2.rects.popper, T2 = "function" == typeof m2 ? m2(Object.assign({}, e2.rects, { placement: e2.placement })) : m2, O2 = "number" == typeof T2 ? { mainAxis: T2, altAxis: T2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, T2), x2 = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, L2 = { x: 0, y: 0 };
        if (E2) {
          if (o2) {
            var $2, D2 = "y" === y2 ? Ei : Ti, k2 = "y" === y2 ? Ai : Ci, N2 = "y" === y2 ? "height" : "width", M2 = E2[y2], S2 = M2 + g2[D2], I2 = M2 - g2[k2], P2 = f2 ? -C2[N2] / 2 : 0, j2 = b2 === Li ? A2[N2] : C2[N2], H2 = b2 === Li ? -C2[N2] : -A2[N2], z2 = e2.elements.arrow, R2 = f2 && z2 ? rn(z2) : { width: 0, height: 0 }, B2 = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, W2 = B2[D2], F2 = B2[k2], q2 = mn(0, A2[N2], R2[N2]), V2 = v2 ? A2[N2] / 2 - P2 - q2 - W2 - O2.mainAxis : j2 - q2 - W2 - O2.mainAxis, Y2 = v2 ? -A2[N2] / 2 + P2 + q2 + F2 + O2.mainAxis : H2 + q2 + F2 + O2.mainAxis, U2 = e2.elements.arrow && fn(e2.elements.arrow), K2 = U2 ? "y" === y2 ? U2.clientTop || 0 : U2.clientLeft || 0 : 0, X2 = null != ($2 = null == x2 ? void 0 : x2[y2]) ? $2 : 0, Q2 = M2 + Y2 - X2, G2 = mn(f2 ? tn(S2, M2 + V2 - X2 - K2) : S2, M2, f2 ? Ji(I2, Q2) : I2);
            E2[y2] = G2, L2[y2] = G2 - M2;
          }
          if (a2) {
            var Z2, J2 = "x" === y2 ? Ei : Ti, tt2 = "x" === y2 ? Ai : Ci, et2 = E2[w2], it2 = "y" === w2 ? "height" : "width", nt2 = et2 + g2[J2], st2 = et2 - g2[tt2], ot2 = -1 !== [Ei, Ti].indexOf(_2), rt2 = null != (Z2 = null == x2 ? void 0 : x2[w2]) ? Z2 : 0, at2 = ot2 ? nt2 : et2 - A2[it2] - C2[it2] - rt2 + O2.altAxis, lt2 = ot2 ? et2 + A2[it2] + C2[it2] - rt2 - O2.altAxis : st2, ct2 = f2 && ot2 ? (dt2 = mn(at2, et2, ht2 = lt2)) > ht2 ? ht2 : dt2 : mn(f2 ? at2 : nt2, et2, f2 ? lt2 : st2);
            E2[w2] = ct2, L2[w2] = ct2 - et2;
          }
          var ht2, dt2;
          e2.modifiersData[n2] = L2;
        }
      }, requiresIfExists: ["offset"] };
      function Yn(t2, e2, i2) {
        void 0 === i2 && (i2 = false);
        var n2, s2, o2 = Xi(e2), r2 = Xi(e2) && function(t3) {
          var e3 = t3.getBoundingClientRect(), i3 = en(e3.width) / t3.offsetWidth || 1, n3 = en(e3.height) / t3.offsetHeight || 1;
          return 1 !== i3 || 1 !== n3;
        }(e2), a2 = hn(e2), l2 = on(t2, r2, i2), c2 = { scrollLeft: 0, scrollTop: 0 }, h2 = { x: 0, y: 0 };
        return (o2 || !o2 && !i2) && (("body" !== Yi(e2) || kn(a2)) && (c2 = (n2 = e2) !== Ui(n2) && Xi(n2) ? { scrollLeft: (s2 = n2).scrollLeft, scrollTop: s2.scrollTop } : $n(n2)), Xi(e2) ? ((h2 = on(e2, true)).x += e2.clientLeft, h2.y += e2.clientTop) : a2 && (h2.x = Dn(a2))), { x: l2.left + c2.scrollLeft - h2.x, y: l2.top + c2.scrollTop - h2.y, width: l2.width, height: l2.height };
      }
      function Un(t2) {
        var e2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Set(), n2 = [];
        function s2(t3) {
          i2.add(t3.name), [].concat(t3.requires || [], t3.requiresIfExists || []).forEach(function(t4) {
            if (!i2.has(t4)) {
              var n3 = e2.get(t4);
              n3 && s2(n3);
            }
          }), n2.push(t3);
        }
        return t2.forEach(function(t3) {
          e2.set(t3.name, t3);
        }), t2.forEach(function(t3) {
          i2.has(t3.name) || s2(t3);
        }), n2;
      }
      var Kn = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function Xn() {
        for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
          e2[i2] = arguments[i2];
        return !e2.some(function(t3) {
          return !(t3 && "function" == typeof t3.getBoundingClientRect);
        });
      }
      function Qn(t2) {
        void 0 === t2 && (t2 = {});
        var e2 = t2, i2 = e2.defaultModifiers, n2 = void 0 === i2 ? [] : i2, s2 = e2.defaultOptions, o2 = void 0 === s2 ? Kn : s2;
        return function(t3, e3, i3) {
          void 0 === i3 && (i3 = o2);
          var s3, r2, a2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Kn, o2), modifiersData: {}, elements: { reference: t3, popper: e3 }, attributes: {}, styles: {} }, l2 = [], c2 = false, h2 = { state: a2, setOptions: function(i4) {
            var s4 = "function" == typeof i4 ? i4(a2.options) : i4;
            d2(), a2.options = Object.assign({}, o2, a2.options, s4), a2.scrollParents = { reference: Ki(t3) ? Mn(t3) : t3.contextElement ? Mn(t3.contextElement) : [], popper: Mn(e3) };
            var r3, c3, u2 = function(t4) {
              var e4 = Un(t4);
              return Vi.reduce(function(t5, i5) {
                return t5.concat(e4.filter(function(t6) {
                  return t6.phase === i5;
                }));
              }, []);
            }((r3 = [].concat(n2, a2.options.modifiers), c3 = r3.reduce(function(t4, e4) {
              var i5 = t4[e4.name];
              return t4[e4.name] = i5 ? Object.assign({}, i5, e4, { options: Object.assign({}, i5.options, e4.options), data: Object.assign({}, i5.data, e4.data) }) : e4, t4;
            }, {}), Object.keys(c3).map(function(t4) {
              return c3[t4];
            })));
            return a2.orderedModifiers = u2.filter(function(t4) {
              return t4.enabled;
            }), a2.orderedModifiers.forEach(function(t4) {
              var e4 = t4.name, i5 = t4.options, n3 = void 0 === i5 ? {} : i5, s5 = t4.effect;
              if ("function" == typeof s5) {
                var o3 = s5({ state: a2, name: e4, instance: h2, options: n3 }), r4 = function() {
                };
                l2.push(o3 || r4);
              }
            }), h2.update();
          }, forceUpdate: function() {
            if (!c2) {
              var t4 = a2.elements, e4 = t4.reference, i4 = t4.popper;
              if (Xn(e4, i4)) {
                a2.rects = { reference: Yn(e4, fn(i4), "fixed" === a2.options.strategy), popper: rn(i4) }, a2.reset = false, a2.placement = a2.options.placement, a2.orderedModifiers.forEach(function(t5) {
                  return a2.modifiersData[t5.name] = Object.assign({}, t5.data);
                });
                for (var n3 = 0; n3 < a2.orderedModifiers.length; n3++)
                  if (true !== a2.reset) {
                    var s4 = a2.orderedModifiers[n3], o3 = s4.fn, r3 = s4.options, l3 = void 0 === r3 ? {} : r3, d3 = s4.name;
                    "function" == typeof o3 && (a2 = o3({ state: a2, options: l3, name: d3, instance: h2 }) || a2);
                  } else
                    a2.reset = false, n3 = -1;
              }
            }
          }, update: (s3 = function() {
            return new Promise(function(t4) {
              h2.forceUpdate(), t4(a2);
            });
          }, function() {
            return r2 || (r2 = new Promise(function(t4) {
              Promise.resolve().then(function() {
                r2 = void 0, t4(s3());
              });
            })), r2;
          }), destroy: function() {
            d2(), c2 = true;
          } };
          if (!Xn(t3, e3))
            return h2;
          function d2() {
            l2.forEach(function(t4) {
              return t4();
            }), l2 = [];
          }
          return h2.setOptions(i3).then(function(t4) {
            !c2 && i3.onFirstUpdate && i3.onFirstUpdate(t4);
          }), h2;
        };
      }
      var Gn = Qn(), Zn = Qn({ defaultModifiers: [Cn, qn, En, Gi] }), Jn = Qn({ defaultModifiers: [Cn, qn, En, Gi, Fn, zn, Vn, bn, Wn] });
      const ts = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: Bi, afterRead: Hi, afterWrite: qi, applyStyles: Gi, arrow: bn, auto: Oi, basePlacements: xi, beforeMain: zi, beforeRead: Pi, beforeWrite: Wi, bottom: Ai, clippingParents: Di, computeStyles: En, createPopper: Jn, createPopperBase: Gn, createPopperLite: Zn, detectOverflow: Hn, end: $i, eventListeners: Cn, flip: zn, hide: Wn, left: Ti, main: Ri, modifierPhases: Vi, offset: Fn, placements: Ii, popper: Ni, popperGenerator: Qn, popperOffsets: qn, preventOverflow: Vn, read: ji, reference: Mi, right: Ci, start: Li, top: Ei, variationPlacements: Si, viewport: ki, write: Fi }, Symbol.toStringTag, { value: "Module" })), es = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, is = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), ns = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, ss = (t2, e2) => {
        const i2 = t2.nodeName.toLowerCase();
        return e2.includes(i2) ? !is.has(i2) || Boolean(ns.test(t2.nodeValue)) : e2.filter((t3) => t3 instanceof RegExp).some((t3) => t3.test(i2));
      };
      const os = { allowList: es, content: {}, extraClass: "", html: false, sanitize: true, sanitizeFn: null, template: "<div></div>" }, rs = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, as = { entry: "(string|element|function|null)", selector: "(string|element)" };
      class ls extends _t {
        constructor(t2) {
          super(), this._config = this._getConfig(t2);
        }
        static get Default() {
          return os;
        }
        static get DefaultType() {
          return rs;
        }
        static get NAME() {
          return "TemplateFactory";
        }
        getContent() {
          return Object.values(this._config.content).map((t2) => this._resolvePossibleFunction(t2)).filter(Boolean);
        }
        hasContent() {
          return this.getContent().length > 0;
        }
        changeContent(t2) {
          return this._checkContent(t2), this._config.content = { ...this._config.content, ...t2 }, this;
        }
        toHtml() {
          const t2 = document.createElement("div");
          t2.innerHTML = this._maybeSanitize(this._config.template);
          for (const [n2, s2] of Object.entries(this._config.content))
            this._setContent(t2, s2, n2);
          const e2 = t2.children[0], i2 = this._resolvePossibleFunction(this._config.extraClass);
          return i2 && e2.classList.add(...i2.split(" ")), e2;
        }
        _typeCheckConfig(t2) {
          super._typeCheckConfig(t2), this._checkContent(t2.content);
        }
        _checkContent(t2) {
          for (const [e2, i2] of Object.entries(t2))
            super._typeCheckConfig({ selector: e2, entry: i2 }, as);
        }
        _setContent(t2, e2, i2) {
          const n2 = Rt.findOne(i2, t2);
          n2 && ((e2 = this._resolvePossibleFunction(e2)) ? R(e2) ? this._putElementInTemplate(B(e2), n2) : this._config.html ? n2.innerHTML = this._maybeSanitize(e2) : n2.textContent = e2 : n2.remove());
        }
        _maybeSanitize(t2) {
          return this._config.sanitize ? function(t3, e2, i2) {
            if (!t3.length)
              return t3;
            if (i2 && "function" == typeof i2)
              return i2(t3);
            const n2 = new window.DOMParser().parseFromString(t3, "text/html"), s2 = [].concat(...n2.body.querySelectorAll("*"));
            for (const o2 of s2) {
              const t4 = o2.nodeName.toLowerCase();
              if (!Object.keys(e2).includes(t4)) {
                o2.remove();
                continue;
              }
              const i3 = [].concat(...o2.attributes), n3 = [].concat(e2["*"] || [], e2[t4] || []);
              for (const e3 of i3)
                ss(e3, n3) || o2.removeAttribute(e3.nodeName);
            }
            return n2.body.innerHTML;
          }(t2, this._config.allowList, this._config.sanitizeFn) : t2;
        }
        _resolvePossibleFunction(t2) {
          return K(t2, [this]);
        }
        _putElementInTemplate(t2, e2) {
          if (this._config.html)
            return e2.innerHTML = "", void e2.append(t2);
          e2.textContent = t2.textContent;
        }
      }
      const cs = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), hs = "fade", ds = "show", us = ".modal", fs = "hide.bs.modal", ps = "hover", ms = "focus", gs = { AUTO: "auto", TOP: "top", RIGHT: U() ? "left" : "right", BOTTOM: "bottom", LEFT: U() ? "right" : "left" }, _s = { allowList: es, animation: true, boundary: "clippingParents", container: false, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: false, offset: [0, 6], placement: "top", popperConfig: null, sanitize: true, sanitizeFn: null, selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, bs = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
      let vs = class t2 extends bt {
        constructor(t3, e2) {
          if (void 0 === ts)
            throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
          super(t3, e2), this._isEnabled = true, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
        }
        static get Default() {
          return _s;
        }
        static get DefaultType() {
          return bs;
        }
        static get NAME() {
          return "tooltip";
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        }
        toggle() {
          this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter());
        }
        dispose() {
          clearTimeout(this._timeout), ut.off(this._element.closest(us), fs, this._hideModalHandler), this._element.getAttribute("data-mdb-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-mdb-original-title")), this._disposePopper(), super.dispose();
        }
        show() {
          if ("none" === this._element.style.display)
            throw new Error("Please use show on visible elements");
          if (!this._isWithContent() || !this._isEnabled)
            return;
          const t3 = ut.trigger(this._element, this.constructor.eventName("show")), e2 = (q(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
          if (t3.defaultPrevented || !e2)
            return;
          this._disposePopper();
          const i2 = this._getTipElement();
          this._element.setAttribute("aria-describedby", i2.getAttribute("id"));
          const { container: n2 } = this._config;
          if (this._element.ownerDocument.documentElement.contains(this.tip) || (n2.append(i2), ut.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i2), i2.classList.add(ds), "ontouchstart" in document.documentElement)
            for (const s2 of [].concat(...document.body.children))
              ut.on(s2, "mouseover", V);
          this._queueCallback(() => {
            ut.trigger(this._element, this.constructor.eventName("shown")), false === this._isHovered && this._leave(), this._isHovered = false;
          }, this.tip, this._isAnimated());
        }
        hide() {
          if (!this._isShown())
            return;
          if (ut.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented)
            return;
          if (this._getTipElement().classList.remove(ds), "ontouchstart" in document.documentElement)
            for (const t3 of [].concat(...document.body.children))
              ut.off(t3, "mouseover", V);
          this._activeTrigger.click = false, this._activeTrigger[ms] = false, this._activeTrigger[ps] = false, this._isHovered = null;
          this._queueCallback(() => {
            this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), ut.trigger(this._element, this.constructor.eventName("hidden")));
          }, this.tip, this._isAnimated());
        }
        update() {
          this._popper && this._popper.update();
        }
        _isWithContent() {
          return Boolean(this._getTitle());
        }
        _getTipElement() {
          return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
        }
        _createTipElement(t3) {
          const e2 = this._getTemplateFactory(t3).toHtml();
          if (!e2)
            return null;
          e2.classList.remove(hs, ds), e2.classList.add(`bs-${this.constructor.NAME}-auto`);
          const i2 = ((t4) => {
            do {
              t4 += Math.floor(1e6 * Math.random());
            } while (document.getElementById(t4));
            return t4;
          })(this.constructor.NAME).toString();
          return e2.setAttribute("id", i2), this._isAnimated() && e2.classList.add(hs), e2;
        }
        setContent(t3) {
          this._newContent = t3, this._isShown() && (this._disposePopper(), this.show());
        }
        _getTemplateFactory(t3) {
          return this._templateFactory ? this._templateFactory.changeContent(t3) : this._templateFactory = new ls({ ...this._config, content: t3, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory;
        }
        _getContentForTemplate() {
          return { ".tooltip-inner": this._getTitle() };
        }
        _getTitle() {
          return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-mdb-original-title");
        }
        _initializeOnDelegatedTarget(t3) {
          return this.constructor.getOrCreateInstance(t3.delegateTarget, this._getDelegateConfig());
        }
        _isAnimated() {
          return this._config.animation || this.tip && this.tip.classList.contains(hs);
        }
        _isShown() {
          return this.tip && this.tip.classList.contains(ds);
        }
        _createPopper(t3) {
          const e2 = K(this._config.placement, [this, t3, this._element]), i2 = gs[e2.toUpperCase()];
          return Jn(this._element, t3, this._getPopperConfig(i2));
        }
        _getOffset() {
          const { offset: t3 } = this._config;
          return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e2) => t3(e2, this._element) : t3;
        }
        _resolvePossibleFunction(t3) {
          return K(t3, [this._element]);
        }
        _getPopperConfig(t3) {
          const e2 = { placement: t3, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: true, phase: "beforeMain", fn: (t4) => {
            this._getTipElement().setAttribute("data-popper-placement", t4.state.placement);
          } }] };
          return { ...e2, ...K(this._config.popperConfig, [e2]) };
        }
        _setListeners() {
          const t3 = this._config.trigger.split(" ");
          for (const e2 of t3)
            if ("click" === e2)
              ut.on(this._element, this.constructor.eventName("click"), this._config.selector, (t4) => {
                this._initializeOnDelegatedTarget(t4).toggle();
              });
            else if ("manual" !== e2) {
              const t4 = e2 === ps ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i2 = e2 === ps ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
              ut.on(this._element, t4, this._config.selector, (t5) => {
                const e3 = this._initializeOnDelegatedTarget(t5);
                e3._activeTrigger["focusin" === t5.type ? ms : ps] = true, e3._enter();
              }), ut.on(this._element, i2, this._config.selector, (t5) => {
                const e3 = this._initializeOnDelegatedTarget(t5);
                e3._activeTrigger["focusout" === t5.type ? ms : ps] = e3._element.contains(t5.relatedTarget), e3._leave();
              });
            }
          this._hideModalHandler = () => {
            this._element && this.hide();
          }, ut.on(this._element.closest(us), fs, this._hideModalHandler);
        }
        _fixTitle() {
          const t3 = this._element.getAttribute("title");
          t3 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t3), this._element.setAttribute("data-mdb-original-title", t3), this._element.removeAttribute("title"));
        }
        _enter() {
          this._isShown() || this._isHovered ? this._isHovered = true : (this._isHovered = true, this._setTimeout(() => {
            this._isHovered && this.show();
          }, this._config.delay.show));
        }
        _leave() {
          this._isWithActiveTrigger() || (this._isHovered = false, this._setTimeout(() => {
            this._isHovered || this.hide();
          }, this._config.delay.hide));
        }
        _setTimeout(t3, e2) {
          clearTimeout(this._timeout), this._timeout = setTimeout(t3, e2);
        }
        _isWithActiveTrigger() {
          return Object.values(this._activeTrigger).includes(true);
        }
        _getConfig(t3) {
          const e2 = gt.getDataAttributes(this._element);
          for (const i2 of Object.keys(e2))
            cs.has(i2) && delete e2[i2];
          return t3 = { ...e2, ..."object" == typeof t3 && t3 ? t3 : {} }, t3 = this._mergeConfigObj(t3), t3 = this._configAfterMerge(t3), this._typeCheckConfig(t3), t3;
        }
        _configAfterMerge(t3) {
          return t3.container = false === t3.container ? document.body : B(t3.container), "number" == typeof t3.delay && (t3.delay = { show: t3.delay, hide: t3.delay }), "number" == typeof t3.title && (t3.title = t3.title.toString()), "number" == typeof t3.content && (t3.content = t3.content.toString()), t3;
        }
        _getDelegateConfig() {
          const t3 = {};
          for (const [e2, i2] of Object.entries(this._config))
            this.constructor.Default[e2] !== i2 && (t3[e2] = i2);
          return t3.selector = false, t3.trigger = "manual", t3;
        }
        _disposePopper() {
          this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2])
                throw new TypeError(`No method named "${e2}"`);
              i2[e2]();
            }
          });
        }
      };
      const ys = { ...vs.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, ws = { ...vs.DefaultType, content: "(null|string|element|function)" };
      let Es = class t2 extends vs {
        static get Default() {
          return ys;
        }
        static get DefaultType() {
          return ws;
        }
        static get NAME() {
          return "popover";
        }
        _isWithContent() {
          return this._getTitle() || this._getContent();
        }
        _getContentForTemplate() {
          return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() };
        }
        _getContent() {
          return this._resolvePossibleFunction(this._config.content);
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2])
                throw new TypeError(`No method named "${e2}"`);
              i2[e2]();
            }
          });
        }
      };
      const As = "popover", Cs = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }, { name: "inserted" }];
      class Ts extends Es {
        constructor(t2, e2) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this.element, "show.bs.popover"), D.off(this.element, "shown.bs.popover"), D.off(this.element, "hide.bs.popover"), D.off(this.element, "hidden.bs.popover"), D.off(this.element, "inserted.bs.popover"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return As;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, Cs, As);
        }
      }
      const Os = ".bs.scrollspy", xs = `activate${Os}`, Ls = `click${Os}`, $s = "active", Ds = "[href]", ks = ".nav-link", Ns = `${ks}, .nav-item > ${ks}, .list-group-item`, Ms = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: false, target: null, threshold: [0.1, 0.5, 1] }, Ss = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
      let Is = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._config.target && (this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh());
        }
        static get Default() {
          return Ms;
        }
        static get DefaultType() {
          return Ss;
        }
        static get NAME() {
          return "scrollspy";
        }
        refresh() {
          this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
          for (const t3 of this._observableSections.values())
            this._observer.observe(t3);
        }
        dispose() {
          this._observer && this._observer.disconnect(), super.dispose();
        }
        _configAfterMerge(t3) {
          return t3.target = B(t3.target) || document.body, t3.rootMargin = t3.offset ? `${t3.offset}px 0px -30%` : t3.rootMargin, "string" == typeof t3.threshold && (t3.threshold = t3.threshold.split(",").map((t4) => Number.parseFloat(t4))), t3;
        }
        _maybeEnableSmoothScroll() {
          this._config.smoothScroll && (ut.off(this._config.target, Ls), ut.on(this._config.target, Ls, Ds, (t3) => {
            const e2 = this._observableSections.get(t3.target.hash);
            if (e2) {
              t3.preventDefault();
              const i2 = this._rootElement || window, n2 = e2.offsetTop - this._element.offsetTop;
              if (i2.scrollTo)
                return void i2.scrollTo({ top: n2, behavior: "smooth" });
              i2.scrollTop = n2;
            }
          }));
        }
        _getNewObserver() {
          const t3 = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
          return new IntersectionObserver((t4) => this._observerCallback(t4), t3);
        }
        _observerCallback(t3) {
          const e2 = (t4) => this._targetLinks.get(`#${t4.target.id}`), i2 = (t4) => {
            this._previousScrollData.visibleEntryTop = t4.target.offsetTop, this._process(e2(t4));
          }, n2 = (this._rootElement || document.documentElement).scrollTop, s2 = n2 >= this._previousScrollData.parentScrollTop;
          this._previousScrollData.parentScrollTop = n2;
          for (const o2 of t3) {
            if (!o2.isIntersecting) {
              this._activeTarget = null, this._clearActiveClass(e2(o2));
              continue;
            }
            const t4 = o2.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (s2 && t4) {
              if (i2(o2), !n2)
                return;
            } else
              s2 || t4 || i2(o2);
          }
        }
        _initializeTargetsAndObservables() {
          this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
          const t3 = Rt.find(Ds, this._config.target);
          for (const e2 of t3) {
            if (!e2.hash || F(e2))
              continue;
            const t4 = Rt.findOne(decodeURI(e2.hash), this._element);
            W(t4) && (this._targetLinks.set(decodeURI(e2.hash), e2), this._observableSections.set(e2.hash, t4));
          }
        }
        _process(t3) {
          this._activeTarget !== t3 && (this._clearActiveClass(this._config.target), this._activeTarget = t3, t3.classList.add($s), this._activateParents(t3), ut.trigger(this._element, xs, { relatedTarget: t3 }));
        }
        _activateParents(t3) {
          if (t3.classList.contains("dropdown-item"))
            Rt.findOne(".dropdown-toggle", t3.closest(".dropdown")).classList.add($s);
          else
            for (const e2 of Rt.parents(t3, ".nav, .list-group"))
              for (const t4 of Rt.prev(e2, Ns))
                t4.classList.add($s);
        }
        _clearActiveClass(t3) {
          t3.classList.remove($s);
          const e2 = Rt.find(`${Ds}.${$s}`, t3);
          for (const i2 of e2)
            i2.classList.remove($s);
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2] || e2.startsWith("_") || "constructor" === e2)
                throw new TypeError(`No method named "${e2}"`);
              i2[e2]();
            }
          });
        }
      };
      const Ps = "scrollspy", js = "activate.bs.scrollspy", Hs = `activate${`.${`mdb.${Ps}`}`}`, zs = "collapsible-scrollspy", Rs = "ul", Bs = `.${zs}`;
      class Ws extends Is {
        constructor(t2, e2) {
          super(t2, e2), this._collapsibles = [], this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._scrollElement, js), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return Ps;
        }
        _init() {
          this._bindActivateEvent(), this._getCollapsibles(), 0 !== this._collapsibles.length && (this._showSubsection(), this._hideSubsection());
        }
        _getHeight(t2) {
          return t2.offsetHeight;
        }
        _hide(t2) {
          const e2 = S.findOne(Rs, t2.parentNode);
          e2.style.overflow = "hidden", e2.style.height = "0px";
        }
        _show(t2, e2) {
          t2.style.height = e2;
        }
        _getCollapsibles() {
          const t2 = S.find(Bs);
          t2 && t2.forEach((t3) => {
            const e2 = t3.parentNode, i2 = S.findOne(Rs, e2), n2 = i2.offsetHeight;
            this._collapsibles.push({ element: i2, relatedTarget: t3.getAttribute("href"), height: `${n2}px` });
          });
        }
        _showSubsection() {
          S.find(".active").filter((t2) => M.hasClass(t2, zs)).forEach((t2) => {
            const e2 = S.findOne(Rs, t2.parentNode), i2 = this._collapsibles.find((e3) => e3.relatedTarget = t2.getAttribute("href")).height;
            this._show(e2, i2);
          });
        }
        _hideSubsection() {
          S.find(Bs).filter((t2) => false === M.hasClass(t2, "active")).forEach((t2) => {
            this._hide(t2);
          });
        }
        _bindActivateEvent() {
          D.on(this._element, js, (t2) => {
            this._showSubsection(), this._hideSubsection(), D.trigger(this._element, Hs, { relatedTarget: t2.relatedTarget });
          });
        }
      }
      const Fs = ".bs.tab", qs = `hide${Fs}`, Vs = `hidden${Fs}`, Ys = `show${Fs}`, Us = `shown${Fs}`, Ks = `keydown${Fs}`, Xs = "ArrowLeft", Qs = "ArrowRight", Gs = "ArrowUp", Zs = "ArrowDown", Js = "Home", to = "End", eo = "active", io = "fade", no = "show", so = ".dropdown-toggle", oo = `:not(${so})`, ro = `${`.nav-link${oo}, .list-group-item${oo}, [role="tab"]${oo}`}, [data-mdb-tab-initialized]`;
      let ao = class t2 extends bt {
        constructor(t3) {
          super(t3), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), ut.on(this._element, Ks, (t4) => this._keydown(t4)));
        }
        static get NAME() {
          return "tab";
        }
        show() {
          const t3 = this._element;
          if (this._elemIsActive(t3))
            return;
          const e2 = this._getActiveElem(), i2 = e2 ? ut.trigger(e2, qs, { relatedTarget: t3 }) : null;
          ut.trigger(t3, Ys, { relatedTarget: e2 }).defaultPrevented || i2 && i2.defaultPrevented || (this._deactivate(e2, t3), this._activate(t3, e2));
        }
        _activate(t3, e2) {
          if (!t3)
            return;
          t3.classList.add(eo), this._activate(Rt.getElementFromSelector(t3));
          this._queueCallback(() => {
            "tab" === t3.getAttribute("role") ? (t3.removeAttribute("tabindex"), t3.setAttribute("aria-selected", true), this._toggleDropDown(t3, true), ut.trigger(t3, Us, { relatedTarget: e2 })) : t3.classList.add(no);
          }, t3, t3.classList.contains(io));
        }
        _deactivate(t3, e2) {
          if (!t3)
            return;
          t3.classList.remove(eo), t3.blur(), this._deactivate(Rt.getElementFromSelector(t3));
          this._queueCallback(() => {
            "tab" === t3.getAttribute("role") ? (t3.setAttribute("aria-selected", false), t3.setAttribute("tabindex", "-1"), this._toggleDropDown(t3, false), ut.trigger(t3, Vs, { relatedTarget: e2 })) : t3.classList.remove(no);
          }, t3, t3.classList.contains(io));
        }
        _keydown(e2) {
          if (![Xs, Qs, Gs, Zs, Js, to].includes(e2.key))
            return;
          e2.stopPropagation(), e2.preventDefault();
          const i2 = this._getChildren().filter((t3) => !F(t3));
          let n2;
          if ([Js, to].includes(e2.key))
            n2 = i2[e2.key === Js ? 0 : i2.length - 1];
          else {
            const t3 = [Qs, Zs].includes(e2.key);
            n2 = Q(i2, e2.target, t3, true);
          }
          n2 && (n2.focus({ preventScroll: true }), t2.getOrCreateInstance(n2).show());
        }
        _getChildren() {
          return Rt.find(ro, this._parent);
        }
        _getActiveElem() {
          return this._getChildren().find((t3) => this._elemIsActive(t3)) || null;
        }
        _setInitialAttributes(t3, e2) {
          this._setAttributeIfNotExists(t3, "role", "tablist");
          for (const i2 of e2)
            this._setInitialAttributesOnChild(i2);
        }
        _setInitialAttributesOnChild(t3) {
          t3 = this._getInnerElement(t3);
          const e2 = this._elemIsActive(t3), i2 = this._getOuterElement(t3);
          t3.setAttribute("aria-selected", e2), i2 !== t3 && this._setAttributeIfNotExists(i2, "role", "presentation"), e2 || t3.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t3, "role", "tab"), this._setInitialAttributesOnTargetPanel(t3);
        }
        _setInitialAttributesOnTargetPanel(t3) {
          const e2 = Rt.getElementFromSelector(t3);
          e2 && (this._setAttributeIfNotExists(e2, "role", "tabpanel"), t3.id && this._setAttributeIfNotExists(e2, "aria-labelledby", `${t3.id}`));
        }
        _toggleDropDown(t3, e2) {
          const i2 = this._getOuterElement(t3);
          if (!i2.classList.contains("dropdown"))
            return;
          const n2 = (t4, n3) => {
            const s2 = Rt.findOne(t4, i2);
            s2 && s2.classList.toggle(n3, e2);
          };
          n2(so, eo), n2(".dropdown-menu", no), i2.setAttribute("aria-expanded", e2);
        }
        _setAttributeIfNotExists(t3, e2, i2) {
          t3.hasAttribute(e2) || t3.setAttribute(e2, i2);
        }
        _elemIsActive(t3) {
          return t3.classList.contains(eo);
        }
        _getInnerElement(t3) {
          return t3.matches(ro) ? t3 : Rt.findOne(ro, t3);
        }
        _getOuterElement(t3) {
          return t3.closest(".nav-item, .list-group-item") || t3;
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2] || e2.startsWith("_") || "constructor" === e2)
                throw new TypeError(`No method named "${e2}"`);
              i2[e2]();
            }
          });
        }
      };
      const lo = ".mdb.tab", co = "show.bs.tab", ho = "shown.bs.tab", uo = `show${lo}`, fo = `shown${lo}`, po = `hide${lo}`, mo = `hidden${lo}`, go = "active", _o = "fade", bo = "show";
      class vo extends ao {
        constructor(t2) {
          super(t2), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, co), D.off(this._element, ho), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return "tab";
        }
        show() {
          const t2 = this._element;
          if (this._elemIsActive(t2))
            return;
          const e2 = this._getActiveElem();
          let i2 = null, n2 = null;
          e2 && (i2 = D.trigger(e2, "hide.bs.tab", { relatedTarget: t2 }), n2 = D.trigger(e2, po, { relatedTarget: t2 }));
          const s2 = D.trigger(t2, co, { relatedTarget: e2 }), o2 = D.trigger(t2, uo, { relatedTarget: e2 });
          s2.defaultPrevented || o2.defaultPrevented || i2 && i2.defaultPrevented || n2 && n2.defaultPrevented || (this._deactivate(e2, t2), this._activate(t2, e2));
        }
        _activate(t2, e2) {
          if (!t2)
            return;
          t2.classList.add(go), this._activate(a(t2));
          this._queueCallback(() => {
            "tab" === t2.getAttribute("role") ? (t2.focus(), t2.removeAttribute("tabindex"), t2.setAttribute("aria-selected", true), this._toggleDropDown(t2, true), D.trigger(t2, ho, { relatedTarget: e2 }), D.trigger(t2, fo, { relatedTarget: e2 })) : t2.classList.add(bo);
          }, t2, t2.classList.contains(_o));
        }
        _deactivate(t2, e2) {
          if (!t2)
            return;
          t2.classList.remove(go), t2.blur(), this._deactivate(a(t2));
          this._queueCallback(() => {
            "tab" === t2.getAttribute("role") ? (t2.setAttribute("aria-selected", false), t2.setAttribute("tabindex", "-1"), this._toggleDropDown(t2, false), D.trigger(t2, "hidden.bs.tab", { relatedTarget: e2 }), D.trigger(t2, mo, { relatedTarget: e2 })) : t2.classList.remove(bo);
          }, t2, t2.classList.contains(_o));
        }
      }
      const yo = "tooltip", wo = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }, { name: "inserted" }];
      class Eo extends vs {
        constructor(t2, e2) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "show.bs.tooltip"), D.off(this._element, "shown.bs.tooltip"), D.off(this._element, "hide.bs.tooltip"), D.off(this._element, "hidden.bs.tooltip"), D.off(this._element, "inserted.bs.tooltip"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return yo;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, wo, yo);
        }
      }
      const Ao = ".bs.toast", Co = `mouseover${Ao}`, To = `mouseout${Ao}`, Oo = `focusin${Ao}`, xo = `focusout${Ao}`, Lo = `hide${Ao}`, $o = `hidden${Ao}`, Do = `show${Ao}`, ko = `shown${Ao}`, No = "hide", Mo = "show", So = "showing", Io = { animation: "boolean", autohide: "boolean", delay: "number" }, Po = { animation: true, autohide: true, delay: 5e3 };
      let jo = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
        }
        static get Default() {
          return Po;
        }
        static get DefaultType() {
          return Io;
        }
        static get NAME() {
          return "toast";
        }
        show() {
          if (ut.trigger(this._element, Do).defaultPrevented)
            return;
          this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
          this._element.classList.remove(No), Y(this._element), this._element.classList.add(Mo, So), this._queueCallback(() => {
            this._element.classList.remove(So), ut.trigger(this._element, ko), this._maybeScheduleHide();
          }, this._element, this._config.animation);
        }
        hide() {
          if (!this.isShown())
            return;
          if (ut.trigger(this._element, Lo).defaultPrevented)
            return;
          this._element.classList.add(So), this._queueCallback(() => {
            this._element.classList.add(No), this._element.classList.remove(So, Mo), ut.trigger(this._element, $o);
          }, this._element, this._config.animation);
        }
        dispose() {
          this._clearTimeout(), this.isShown() && this._element.classList.remove(Mo), super.dispose();
        }
        isShown() {
          return this._element.classList.contains(Mo);
        }
        _maybeScheduleHide() {
          this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
        }
        _onInteraction(t3, e2) {
          switch (t3.type) {
            case "mouseover":
            case "mouseout":
              this._hasMouseInteraction = e2;
              break;
            case "focusin":
            case "focusout":
              this._hasKeyboardInteraction = e2;
          }
          if (e2)
            return void this._clearTimeout();
          const i2 = t3.relatedTarget;
          this._element === i2 || this._element.contains(i2) || this._maybeScheduleHide();
        }
        _setListeners() {
          ut.on(this._element, Co, (t3) => this._onInteraction(t3, true)), ut.on(this._element, To, (t3) => this._onInteraction(t3, false)), ut.on(this._element, Oo, (t3) => this._onInteraction(t3, true)), ut.on(this._element, xo, (t3) => this._onInteraction(t3, false));
        }
        _clearTimeout() {
          clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2])
                throw new TypeError(`No method named "${e2}"`);
              i2[e2](this);
            }
          });
        }
      };
      const Ho = "toast", zo = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }];
      class Ro extends jo {
        constructor(t2, e2) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "show.bs.toast"), D.off(this._element, "shown.bs.toast"), D.off(this._element, "hide.bs.toast"), D.off(this._element, "hidden.bs.toast"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return Ho;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, zo, Ho);
        }
      }
      (() => {
        var t2 = { 454: (t3, e3, i3) => {
          i3.d(e3, { Z: () => o2 });
          var n2 = i3(645), s2 = i3.n(n2)()(function(t4) {
            return t4[1];
          });
          s2.push([t3.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
          const o2 = s2;
        }, 645: (t3) => {
          t3.exports = function(t4) {
            var e3 = [];
            return e3.toString = function() {
              return this.map(function(e4) {
                var i3 = t4(e4);
                return e4[2] ? "@media ".concat(e4[2], " {").concat(i3, "}") : i3;
              }).join("");
            }, e3.i = function(t5, i3, n2) {
              "string" == typeof t5 && (t5 = [[null, t5, ""]]);
              var s2 = {};
              if (n2)
                for (var o2 = 0; o2 < this.length; o2++) {
                  var r2 = this[o2][0];
                  null != r2 && (s2[r2] = true);
                }
              for (var a2 = 0; a2 < t5.length; a2++) {
                var l2 = [].concat(t5[a2]);
                n2 && s2[l2[0]] || (i3 && (l2[2] ? l2[2] = "".concat(i3, " and ").concat(l2[2]) : l2[2] = i3), e3.push(l2));
              }
            }, e3;
          };
        }, 810: () => {
          !function() {
            if ("undefined" != typeof window)
              try {
                var t3 = new window.CustomEvent("test", { cancelable: true });
                if (t3.preventDefault(), true !== t3.defaultPrevented)
                  throw new Error("Could not prevent default");
              } catch (i3) {
                var e3 = function(t4, e4) {
                  var i4, n2;
                  return (e4 = e4 || {}).bubbles = !!e4.bubbles, e4.cancelable = !!e4.cancelable, (i4 = document.createEvent("CustomEvent")).initCustomEvent(t4, e4.bubbles, e4.cancelable, e4.detail), n2 = i4.preventDefault, i4.preventDefault = function() {
                    n2.call(this);
                    try {
                      Object.defineProperty(this, "defaultPrevented", { get: function() {
                        return true;
                      } });
                    } catch (t5) {
                      this.defaultPrevented = true;
                    }
                  }, i4;
                };
                e3.prototype = window.Event.prototype, window.CustomEvent = e3;
              }
          }();
        }, 379: (t3, e3, i3) => {
          var n2, s2, o2 = (s2 = {}, function(t4) {
            if (void 0 === s2[t4]) {
              var e4 = document.querySelector(t4);
              if (window.HTMLIFrameElement && e4 instanceof window.HTMLIFrameElement)
                try {
                  e4 = e4.contentDocument.head;
                } catch (i4) {
                  e4 = null;
                }
              s2[t4] = e4;
            }
            return s2[t4];
          }), r2 = [];
          function a2(t4) {
            for (var e4 = -1, i4 = 0; i4 < r2.length; i4++)
              if (r2[i4].identifier === t4) {
                e4 = i4;
                break;
              }
            return e4;
          }
          function l2(t4, e4) {
            for (var i4 = {}, n3 = [], s3 = 0; s3 < t4.length; s3++) {
              var o3 = t4[s3], l3 = e4.base ? o3[0] + e4.base : o3[0], c3 = i4[l3] || 0, h3 = "".concat(l3, " ").concat(c3);
              i4[l3] = c3 + 1;
              var d3 = a2(h3), u3 = { css: o3[1], media: o3[2], sourceMap: o3[3] };
              -1 !== d3 ? (r2[d3].references++, r2[d3].updater(u3)) : r2.push({ identifier: h3, updater: g2(u3, e4), references: 1 }), n3.push(h3);
            }
            return n3;
          }
          function c2(t4) {
            var e4 = document.createElement("style"), n3 = t4.attributes || {};
            if (void 0 === n3.nonce) {
              var s3 = i3.nc;
              s3 && (n3.nonce = s3);
            }
            if (Object.keys(n3).forEach(function(t5) {
              e4.setAttribute(t5, n3[t5]);
            }), "function" == typeof t4.insert)
              t4.insert(e4);
            else {
              var r3 = o2(t4.insert || "head");
              if (!r3)
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              r3.appendChild(e4);
            }
            return e4;
          }
          var h2, d2 = (h2 = [], function(t4, e4) {
            return h2[t4] = e4, h2.filter(Boolean).join("\n");
          });
          function u2(t4, e4, i4, n3) {
            var s3 = i4 ? "" : n3.media ? "@media ".concat(n3.media, " {").concat(n3.css, "}") : n3.css;
            if (t4.styleSheet)
              t4.styleSheet.cssText = d2(e4, s3);
            else {
              var o3 = document.createTextNode(s3), r3 = t4.childNodes;
              r3[e4] && t4.removeChild(r3[e4]), r3.length ? t4.insertBefore(o3, r3[e4]) : t4.appendChild(o3);
            }
          }
          function f2(t4, e4, i4) {
            var n3 = i4.css, s3 = i4.media, o3 = i4.sourceMap;
            if (s3 ? t4.setAttribute("media", s3) : t4.removeAttribute("media"), o3 && "undefined" != typeof btoa && (n3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o3)))), " */")), t4.styleSheet)
              t4.styleSheet.cssText = n3;
            else {
              for (; t4.firstChild; )
                t4.removeChild(t4.firstChild);
              t4.appendChild(document.createTextNode(n3));
            }
          }
          var p2 = null, m2 = 0;
          function g2(t4, e4) {
            var i4, n3, s3;
            if (e4.singleton) {
              var o3 = m2++;
              i4 = p2 || (p2 = c2(e4)), n3 = u2.bind(null, i4, o3, false), s3 = u2.bind(null, i4, o3, true);
            } else
              i4 = c2(e4), n3 = f2.bind(null, i4, e4), s3 = function() {
                !function(t5) {
                  if (null === t5.parentNode)
                    return false;
                  t5.parentNode.removeChild(t5);
                }(i4);
              };
            return n3(t4), function(e5) {
              if (e5) {
                if (e5.css === t4.css && e5.media === t4.media && e5.sourceMap === t4.sourceMap)
                  return;
                n3(t4 = e5);
              } else
                s3();
            };
          }
          t3.exports = function(t4, e4) {
            (e4 = e4 || {}).singleton || "boolean" == typeof e4.singleton || (e4.singleton = (void 0 === n2 && (n2 = Boolean(window && document && document.all && !window.atob)), n2));
            var i4 = l2(t4 = t4 || [], e4);
            return function(t5) {
              if (t5 = t5 || [], "[object Array]" === Object.prototype.toString.call(t5)) {
                for (var n3 = 0; n3 < i4.length; n3++) {
                  var s3 = a2(i4[n3]);
                  r2[s3].references--;
                }
                for (var o3 = l2(t5, e4), c3 = 0; c3 < i4.length; c3++) {
                  var h3 = a2(i4[c3]);
                  0 === r2[h3].references && (r2[h3].updater(), r2.splice(h3, 1));
                }
                i4 = o3;
              }
            };
          };
        } }, e2 = {};
        function i2(n2) {
          var s2 = e2[n2];
          if (void 0 !== s2)
            return s2.exports;
          var o2 = e2[n2] = { id: n2, exports: {} };
          return t2[n2](o2, o2.exports, i2), o2.exports;
        }
        i2.n = (t3) => {
          var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
          return i2.d(e3, { a: e3 }), e3;
        }, i2.d = (t3, e3) => {
          for (var n2 in e3)
            i2.o(e3, n2) && !i2.o(t3, n2) && Object.defineProperty(t3, n2, { enumerable: true, get: e3[n2] });
        }, i2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), (() => {
          var t3 = i2(379), e3 = i2.n(t3), n2 = i2(454);
          function s2(t4) {
            if (!t4.hasAttribute("autocompleted")) {
              t4.setAttribute("autocompleted", "");
              var e4 = new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: true, detail: null });
              t4.dispatchEvent(e4) || (t4.value = "");
            }
          }
          function o2(t4) {
            t4.hasAttribute("autocompleted") && (t4.removeAttribute("autocompleted"), t4.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: false, detail: null })));
          }
          e3()(n2.Z, { insert: "head", singleton: false }), n2.Z.locals, i2(810), document.addEventListener("animationstart", function(t4) {
            "onautofillstart" === t4.animationName ? s2(t4.target) : o2(t4.target);
          }, true), document.addEventListener("input", function(t4) {
            "insertReplacementText" !== t4.inputType && "data" in t4 ? o2(t4.target) : s2(t4.target);
          }, true);
        })();
      })();
      class Bo {
        constructor(t2) {
          (t2 = c(t2)) && (this._element = t2, s.setData(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
          s.removeData(this._element, this.constructor.DATA_KEY), D.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t2) => {
            this[t2] = null;
          });
        }
        static getInstance(t2) {
          return s.getData(c(t2), this.DATA_KEY);
        }
        static getOrCreateInstance(t2, e2 = {}) {
          return this.getInstance(t2) || new this(t2, "object" == typeof e2 ? e2 : null);
        }
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
        static get DATA_KEY() {
          return `mdb.${this.NAME}`;
        }
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
      }
      const Wo = "active", Fo = "form-notch", qo = "form-notch-leading", Vo = "form-notch-middle", Yo = `.${Fo}`, Uo = `.${qo}`, Ko = `.${Vo}`;
      class Xo extends Bo {
        constructor(t2) {
          super(t2), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = false, this._helper = null, this._counter = false, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (this.init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor));
        }
        static get NAME() {
          return "input";
        }
        get input() {
          return S.findOne("input", this._element) || S.findOne("textarea", this._element);
        }
        init() {
          this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._initiated = true);
        }
        update() {
          this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
        }
        forceActive() {
          M.addClass(this.input, Wo);
        }
        forceInactive() {
          M.removeClass(this.input, Wo);
        }
        dispose() {
          this._removeBorder(), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        _getLabelData() {
          this._label = S.findOne("label", this._element), null === this._label ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
        }
        _getHelper() {
          this._helper = S.findOne(".form-helper", this._element);
        }
        _getCounter() {
          this._counter = M.getDataAttribute(this.input, "showcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
        }
        _showCounter() {
          if (S.find(".form-counter", this._element).length > 0)
            return;
          this._counterElement = document.createElement("div"), M.addClass(this._counterElement, "form-counter");
          const t2 = this.input.value.length;
          this._counterElement.innerHTML = `${t2} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
        }
        _bindCounter() {
          D.on(this.input, "input", () => {
            const t2 = this.input.value.length;
            this._counterElement.innerHTML = `${t2} / ${this._maxLength}`;
          });
        }
        _toggleDefaultDatePlaceholder(t2 = this.input) {
          const e2 = t2.getAttribute("type");
          if (!["date", "time", "datetime-local", "month", "week"].includes(e2))
            return;
          document.activeElement === t2 || t2.value ? t2.style.opacity = 1 : t2.style.opacity = 0;
        }
        _showPlaceholder() {
          M.addClass(this.input, "placeholder-active");
        }
        _getNotchData() {
          this._notchMiddle = S.findOne(Ko, this._element), this._notchLeading = S.findOne(Uo, this._element);
        }
        _getLabelWidth() {
          this._labelWidth = 0.8 * this._label.clientWidth + 8;
        }
        _getLabelPositionInInputGroup() {
          if (this._labelMarginLeft = 0, !this._element.classList.contains("input-group"))
            return;
          const t2 = this.input, e2 = S.prev(t2, ".input-group-text")[0];
          this._labelMarginLeft = void 0 === e2 ? 0 : e2.offsetWidth - 1;
        }
        _applyDivs() {
          const t2 = S.find(Yo, this._element), e2 = m("div");
          M.addClass(e2, Fo), this._notchLeading = m("div"), M.addClass(this._notchLeading, qo), this._notchMiddle = m("div"), M.addClass(this._notchMiddle, Vo), this._notchTrailing = m("div"), M.addClass(this._notchTrailing, "form-notch-trailing"), t2.length >= 1 || (e2.append(this._notchLeading), e2.append(this._notchMiddle), e2.append(this._notchTrailing), this._element.append(e2));
        }
        _applyNotch() {
          this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, null !== this._label && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
        }
        _removeBorder() {
          const t2 = S.findOne(Yo, this._element);
          t2 && t2.remove();
        }
        _activate(t2) {
          p(() => {
            if (this._getElements(t2), !this._element)
              return;
            const e2 = t2 ? t2.target : this.input;
            "" !== e2.value && M.addClass(e2, Wo), this._toggleDefaultDatePlaceholder(e2);
          });
        }
        _getElements(t2) {
          let e2;
          if (t2 && (this._element = t2.target.parentNode, this._label = S.findOne("label", this._element), e2 = M.getDataAttribute(this._element, `${this.constructor.NAME}-initialized`)), e2 && t2 && this._label) {
            const e3 = this._labelWidth;
            this._getLabelData(), e3 !== this._labelWidth && (this._notchMiddle = S.findOne(".form-notch-middle", t2.target.parentNode), this._notchLeading = S.findOne(Uo, t2.target.parentNode), this._applyNotch());
          }
        }
        _deactivate(t2) {
          const e2 = t2 ? t2.target : this.input;
          "" === e2.value && e2.classList.remove(Wo), this._toggleDefaultDatePlaceholder(e2);
        }
        static activate(t2) {
          return function(e2) {
            t2._activate(e2);
          };
        }
        static deactivate(t2) {
          return function(e2) {
            t2._deactivate(e2);
          };
        }
        static jQueryInterface(t2, e2) {
          return this.each(function() {
            let i2 = s.getData(this, "mdb.input");
            const n2 = "object" == typeof t2 && t2;
            if ((i2 || !/dispose/.test(t2)) && (i2 || (i2 = new Xo(this, n2)), "string" == typeof t2)) {
              if (void 0 === i2[t2])
                throw new TypeError(`No method named "${t2}"`);
              i2[t2](e2);
            }
          });
        }
      }
      const Qo = ".bs.collapse", Go = `show${Qo}`, Zo = `shown${Qo}`, Jo = `hide${Qo}`, tr = `hidden${Qo}`, er = "show", ir = "collapse", nr = "collapsing", sr = `:scope .${ir} .${ir}`, or = "[data-mdb-collapse-init]", rr = { parent: null, toggle: true }, ar = { parent: "(null|element)", toggle: "boolean" };
      let lr = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._isTransitioning = false, this._triggerArray = [];
          const i2 = Rt.find(or);
          for (const n2 of i2) {
            const t4 = Rt.getSelectorFromElement(n2), e3 = Rt.find(t4).filter((t5) => t5 === this._element);
            null !== t4 && e3.length && this._triggerArray.push(n2);
          }
          this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
          return rr;
        }
        static get DefaultType() {
          return ar;
        }
        static get NAME() {
          return "collapse";
        }
        toggle() {
          this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (this._isTransitioning || this._isShown())
            return;
          let e2 = [];
          if (this._config.parent && (e2 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t3) => t3 !== this._element).map((e3) => t2.getOrCreateInstance(e3, { toggle: false }))), e2.length && e2[0]._isTransitioning)
            return;
          if (ut.trigger(this._element, Go).defaultPrevented)
            return;
          for (const t3 of e2)
            t3.hide();
          const i2 = this._getDimension();
          this._element.classList.remove(ir), this._element.classList.add(nr), this._element.style[i2] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
          const n2 = `scroll${i2[0].toUpperCase() + i2.slice(1)}`;
          this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(nr), this._element.classList.add(ir, er), this._element.style[i2] = "", ut.trigger(this._element, Zo);
          }, this._element, true), this._element.style[i2] = `${this._element[n2]}px`;
        }
        hide() {
          if (this._isTransitioning || !this._isShown())
            return;
          if (ut.trigger(this._element, Jo).defaultPrevented)
            return;
          const t3 = this._getDimension();
          this._element.style[t3] = `${this._element.getBoundingClientRect()[t3]}px`, Y(this._element), this._element.classList.add(nr), this._element.classList.remove(ir, er);
          for (const e2 of this._triggerArray) {
            const t4 = Rt.getElementFromSelector(e2);
            t4 && !this._isShown(t4) && this._addAriaAndCollapsedClass([e2], false);
          }
          this._isTransitioning = true;
          this._element.style[t3] = "", this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(nr), this._element.classList.add(ir), ut.trigger(this._element, tr);
          }, this._element, true);
        }
        _isShown(t3 = this._element) {
          return t3.classList.contains(er);
        }
        _configAfterMerge(t3) {
          return t3.toggle = Boolean(t3.toggle), t3.parent = B(t3.parent), t3;
        }
        _getDimension() {
          return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
          if (!this._config.parent)
            return;
          const t3 = this._getFirstLevelChildren(or);
          for (const e2 of t3) {
            const t4 = Rt.getElementFromSelector(e2);
            t4 && this._addAriaAndCollapsedClass([e2], this._isShown(t4));
          }
        }
        _getFirstLevelChildren(t3) {
          const e2 = Rt.find(sr, this._config.parent);
          return Rt.find(t3, this._config.parent).filter((t4) => !e2.includes(t4));
        }
        _addAriaAndCollapsedClass(t3, e2) {
          if (t3.length)
            for (const i2 of t3)
              i2.classList.toggle("collapsed", !e2), i2.setAttribute("aria-expanded", e2);
        }
        static jQueryInterface(e2) {
          const i2 = {};
          return "string" == typeof e2 && /show|hide/.test(e2) && (i2.toggle = false), this.each(function() {
            const n2 = t2.getOrCreateInstance(this, i2);
            if ("string" == typeof e2) {
              if (void 0 === n2[e2])
                throw new TypeError(`No method named "${e2}"`);
              n2[e2]();
            }
          });
        }
      };
      const cr = "collapse", hr = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }];
      class dr extends lr {
        constructor(t2, e2 = {}) {
          super(t2, e2), this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, "show.bs.collapse"), D.off(this._element, "shown.bs.collapse"), D.off(this._element, "hide.bs.collapse"), D.off(this._element, "hidden.bs.collapse"), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return cr;
        }
        _init() {
          this._bindMdbEvents();
        }
        _bindMdbEvents() {
          D.extend(this._element, hr, cr);
        }
      }
      const ur = "dropdown", fr = ".bs.dropdown", pr = "ArrowUp", mr = "ArrowDown", gr = `hide${fr}`, _r = `hidden${fr}`, br = `show${fr}`, vr = `shown${fr}`, yr = "show", wr = "[data-mdb-dropdown-initialized]:not(.disabled):not(:disabled)", Er = `${wr}.${yr}`, Ar = ".dropdown-menu", Cr = U() ? "top-end" : "top-start", Tr = U() ? "top-start" : "top-end", Or = U() ? "bottom-end" : "bottom-start", xr = U() ? "bottom-start" : "bottom-end", Lr = U() ? "left-start" : "right-start", $r = U() ? "right-start" : "left-start", Dr = { autoClose: true, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, kr = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
      let Nr = class t2 extends bt {
        constructor(t3, e2) {
          super(t3, e2), this._popper = null, this._parent = this._element.parentNode, this._menu = Rt.next(this._element, Ar)[0] || Rt.prev(this._element, Ar)[0] || Rt.findOne(Ar, this._parent), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
          return Dr;
        }
        static get DefaultType() {
          return kr;
        }
        static get NAME() {
          return ur;
        }
        toggle() {
          return this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (F(this._element) || this._isShown())
            return;
          const t3 = { relatedTarget: this._element };
          if (!ut.trigger(this._element, br, t3).defaultPrevented) {
            if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
              for (const t4 of [].concat(...document.body.children))
                ut.on(t4, "mouseover", V);
            this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add(yr), this._element.classList.add(yr), ut.trigger(this._element, vr, t3);
          }
        }
        hide() {
          if (F(this._element) || !this._isShown())
            return;
          const t3 = { relatedTarget: this._element };
          this._completeHide(t3);
        }
        dispose() {
          this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
          this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t3) {
          if (!ut.trigger(this._element, gr, t3).defaultPrevented) {
            if ("ontouchstart" in document.documentElement)
              for (const t4 of [].concat(...document.body.children))
                ut.off(t4, "mouseover", V);
            this._popper && this._popper.destroy(), this._menu.classList.remove(yr), this._element.classList.remove(yr), this._element.setAttribute("aria-expanded", "false"), gt.removeDataAttribute(this._menu, "popper"), ut.trigger(this._element, _r, t3);
          }
        }
        _getConfig(t3) {
          if ("object" == typeof (t3 = super._getConfig(t3)).reference && !R(t3.reference) && "function" != typeof t3.reference.getBoundingClientRect)
            throw new TypeError(`${ur.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
          return t3;
        }
        _createPopper() {
          if (void 0 === ts)
            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
          let t3 = this._element;
          "parent" === this._config.reference ? t3 = this._parent : R(this._config.reference) ? t3 = B(this._config.reference) : "object" == typeof this._config.reference && (t3 = this._config.reference);
          const e2 = this._getPopperConfig();
          this._popper = Jn(t3, this._menu, e2);
        }
        _isShown() {
          return this._menu.classList.contains(yr);
        }
        _getPlacement() {
          const t3 = this._parent;
          if (t3.classList.contains("dropend"))
            return Lr;
          if (t3.classList.contains("dropstart"))
            return $r;
          if (t3.classList.contains("dropup-center"))
            return "top";
          if (t3.classList.contains("dropdown-center"))
            return "bottom";
          const e2 = "end" === getComputedStyle(this._menu).getPropertyValue("--mdb-position").trim();
          return t3.classList.contains("dropup") ? e2 ? Tr : Cr : e2 ? xr : Or;
        }
        _detectNavbar() {
          return null !== this._element.closest(".navbar");
        }
        _getOffset() {
          const { offset: t3 } = this._config;
          return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e2) => t3(e2, this._element) : t3;
        }
        _getPopperConfig() {
          const t3 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
          return (this._inNavbar || "static" === this._config.display) && (gt.setDataAttribute(this._menu, "popper", "static"), t3.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t3, ...K(this._config.popperConfig, [t3]) };
        }
        _selectMenuItem({ key: t3, target: e2 }) {
          const i2 = Rt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t4) => W(t4));
          i2.length && Q(i2, e2, t3 === mr, !i2.includes(e2)).focus();
        }
        static jQueryInterface(e2) {
          return this.each(function() {
            const i2 = t2.getOrCreateInstance(this, e2);
            if ("string" == typeof e2) {
              if (void 0 === i2[e2])
                throw new TypeError(`No method named "${e2}"`);
              i2[e2]();
            }
          });
        }
        static clearMenus(e2) {
          if (2 === e2.button || "keyup" === e2.type && "Tab" !== e2.key)
            return;
          const i2 = Rt.find(Er);
          for (const n2 of i2) {
            const i3 = t2.getInstance(n2);
            if (!i3 || false === i3._config.autoClose)
              continue;
            const s2 = e2.composedPath(), o2 = s2.includes(i3._menu);
            if (s2.includes(i3._element) || "inside" === i3._config.autoClose && !o2 || "outside" === i3._config.autoClose && o2)
              continue;
            if (i3._menu.contains(e2.target) && ("keyup" === e2.type && "Tab" === e2.key || /input|select|option|textarea|form/i.test(e2.target.tagName)))
              continue;
            const r2 = { relatedTarget: i3._element };
            "click" === e2.type && (r2.clickEvent = e2), i3._completeHide(r2);
          }
        }
        static dataApiKeydownHandler(e2) {
          const i2 = /input|textarea/i.test(e2.target.tagName), n2 = "Escape" === e2.key, s2 = [pr, mr].includes(e2.key);
          if (!s2 && !n2)
            return;
          if (i2 && !n2)
            return;
          e2.preventDefault();
          const o2 = this.matches(wr) ? this : Rt.prev(this, wr)[0] || Rt.next(this, wr)[0] || Rt.findOne(wr, e2.delegateTarget.parentNode), r2 = t2.getOrCreateInstance(o2);
          if (s2)
            return e2.stopPropagation(), r2.show(), void r2._selectMenuItem(e2);
          r2._isShown() && (e2.stopPropagation(), r2.hide(), o2.focus());
        }
      };
      const Mr = "dropdown", Sr = `.${`mdb.${Mr}`}`, Ir = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, dropdownAnimation: "on" }, Pr = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", dropdownAnimation: "string" }, jr = "hide.bs.dropdown", Hr = "hidden.bs.dropdown", zr = "show.bs.dropdown", Rr = "shown.bs.dropdown", Br = `hide${Sr}`, Wr = `hidden${Sr}`, Fr = `show${Sr}`, qr = `shown${Sr}`, Vr = "animation", Yr = "fade-in", Ur = "fade-out";
      class Kr extends Nr {
        constructor(t2, e2) {
          super(t2, e2), this._config = this._getConfig(e2), this._menuStyle = "", this._popperPlacement = "", this._mdbPopperConfig = "";
          const i2 = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          "on" !== this._config.dropdownAnimation || i2 || this._init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor);
        }
        dispose() {
          D.off(this._element, zr), D.off(this._parent, Rr), D.off(this._parent, jr), D.off(this._parent, Hr), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        static get NAME() {
          return Mr;
        }
        _init() {
          this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent();
        }
        _getConfig(t2) {
          const e2 = { ...Ir, ...M.getDataAttributes(this._element), ...t2 };
          return h(Mr, e2, Pr), e2;
        }
        _getOffset() {
          const { offset: t2 } = this._config;
          return "string" == typeof t2 ? t2.split(",").map((t3) => Number.parseInt(t3, 10)) : "function" == typeof t2 ? (e2) => t2(e2, this._element) : t2;
        }
        _getPopperConfig() {
          const t2 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
          return "static" === this._config.display && (M.setDataAttribute(this._menu, "popper", "static"), t2.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t2, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t2) : this._config.popperConfig };
        }
        _bindShowEvent() {
          D.on(this._element, zr, (t2) => {
            D.trigger(this._element, Fr, { relatedTarget: t2.relatedTarget }).defaultPrevented ? t2.preventDefault() : this._dropdownAnimationStart("show");
          });
        }
        _bindShownEvent() {
          D.on(this._parent, Rr, (t2) => {
            D.trigger(this._parent, qr, { relatedTarget: t2.relatedTarget }).defaultPrevented && t2.preventDefault();
          });
        }
        _bindHideEvent() {
          D.on(this._parent, jr, (t2) => {
            D.trigger(this._parent, Br, { relatedTarget: t2.relatedTarget }).defaultPrevented ? t2.preventDefault() : (this._menuStyle = this._menu.style.cssText, this._popperPlacement = this._menu.getAttribute("data-popper-placement"), this._mdbPopperConfig = this._menu.getAttribute("data-mdb-popper"));
          });
        }
        _bindHiddenEvent() {
          D.on(this._parent, Hr, (t2) => {
            D.trigger(this._parent, Wr, { relatedTarget: t2.relatedTarget }).defaultPrevented ? t2.preventDefault() : ("static" !== this._config.display && "" !== this._menuStyle && (this._menu.style.cssText = this._menuStyle), this._menu.setAttribute("data-popper-placement", this._popperPlacement), this._menu.setAttribute("data-mdb-popper", this._mdbPopperConfig), this._dropdownAnimationStart("hide"));
          });
        }
        _dropdownAnimationStart(t2) {
          if ("show" === t2)
            this._menu.classList.add(Vr, Yr), this._menu.classList.remove(Ur);
          else
            this._menu.classList.add(Vr, Ur), this._menu.classList.remove(Yr);
          this._bindAnimationEnd();
        }
        _bindAnimationEnd() {
          D.one(this._menu, "animationend", () => {
            this._menu.classList.remove(Vr, Ur, Yr);
          });
        }
      }
      const Xr = "ripple", Qr = "ripple-surface", Gr = "ripple-wave", Zr = "input-wrapper", Jr = [".btn", `[data-mdb-${Xr}-init]`], ta = "ripple-surface-unbound", ea = [0, 0, 0], ia = ["primary", "secondary", "success", "danger", "warning", "info", "light", "dark"], na = { rippleCentered: false, rippleColor: "", rippleDuration: "500ms", rippleRadius: 0, rippleUnbound: false }, sa = { rippleCentered: "boolean", rippleColor: "string", rippleDuration: "string", rippleRadius: "number", rippleUnbound: "boolean" };
      class oa extends Bo {
        constructor(t2, e2) {
          super(t2), this._options = this._getConfig(e2), this._element && (M.addClass(this._element, Qr), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = false, this._rippleInSpan = false, this.init();
        }
        static get NAME() {
          return Xr;
        }
        init() {
          this._addClickEvent(this._element);
        }
        dispose() {
          D.off(this._element, "mousedown", this._clickHandler), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        _autoInit(t2) {
          Jr.forEach((e3) => {
            S.closest(t2.target, e3) && (this._element = S.closest(t2.target, e3));
          });
          const e2 = M.getDataAttributes(this._element);
          if (!this._element.classList.contains("btn") || false !== e2.rippleInit) {
            if (this._options = this._getConfig(), "input" === this._element.tagName.toLowerCase()) {
              const t3 = this._element.parentNode;
              if (this._rippleInSpan = true, "span" === t3.tagName.toLowerCase() && t3.classList.contains(Qr))
                this._element = t3;
              else {
                const e3 = getComputedStyle(this._element).boxShadow, i2 = this._element, n2 = document.createElement("span");
                i2.classList.contains("btn-block") && (n2.style.display = "block"), D.one(n2, "mouseup", (t4) => {
                  0 === t4.button && i2.click();
                }), n2.classList.add(Qr, Zr), M.addStyle(n2, { border: 0, "box-shadow": e3 }), t3.replaceChild(n2, this._element), n2.appendChild(this._element), this._element = n2;
              }
              this._element.focus();
            }
            this._element.style.minWidth || (M.style(this._element, { "min-width": `${getComputedStyle(this._element).width}` }), this._isMinWidthSet = true), M.addClass(this._element, Qr), this._createRipple(t2);
          }
        }
        _addClickEvent(t2) {
          D.on(t2, "mousedown", this._clickHandler);
        }
        _getEventLayer(t2) {
          return { layerX: Math.round(t2.clientX - t2.target.getBoundingClientRect().x), layerY: Math.round(t2.clientY - t2.target.getBoundingClientRect().y) };
        }
        _createRipple(t2) {
          if (null === this._element)
            return;
          M.hasClass(this._element, Qr) || M.addClass(this._element, Qr);
          const { layerX: e2, layerY: i2 } = this._getEventLayer(t2), n2 = e2, s2 = i2, o2 = this._element.offsetHeight, r2 = this._element.offsetWidth, a2 = this._durationToMsNumber(this._options.rippleDuration), l2 = { offsetX: this._options.rippleCentered ? o2 / 2 : n2, offsetY: this._options.rippleCentered ? r2 / 2 : s2, height: o2, width: r2 }, c2 = this._getDiameter(l2), h2 = this._options.rippleRadius || c2 / 2, d2 = 0.5 * a2, u2 = a2 - 0.5 * a2, f2 = { left: this._options.rippleCentered ? r2 / 2 - h2 + "px" : n2 - h2 + "px", top: this._options.rippleCentered ? o2 / 2 - h2 + "px" : s2 - h2 + "px", height: `${2 * this._options.rippleRadius || c2}px`, width: `${2 * this._options.rippleRadius || c2}px`, transitionDelay: `0s, ${d2}ms`, transitionDuration: `${a2}ms, ${u2}ms` }, p2 = m("div");
          this._createHTMLRipple({ wrapper: this._element, ripple: p2, styles: f2 }), this._removeHTMLRipple({ ripple: p2, duration: a2 });
        }
        _createHTMLRipple({ wrapper: t2, ripple: e2, styles: i2 }) {
          Object.keys(i2).forEach((t3) => e2.style[t3] = i2[t3]), e2.classList.add(Gr), "" !== this._options.rippleColor && (this._removeOldColorClasses(t2), this._addColor(e2, t2)), this._toggleUnbound(t2), this._appendRipple(e2, t2);
        }
        _removeHTMLRipple({ ripple: t2, duration: e2 }) {
          this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), this._rippleTimer = setTimeout(() => {
            t2 && (t2.remove(), this._element && (S.find(`.${Gr}`, this._element).forEach((t3) => {
              t3.remove();
            }), this._isMinWidthSet && (M.style(this._element, { "min-width": "" }), this._isMinWidthSet = false), this._rippleInSpan && this._element.classList.contains(Zr) ? this._removeWrapperSpan() : M.removeClass(this._element, Qr)));
          }, e2);
        }
        _removeWrapperSpan() {
          const t2 = this._element.firstChild;
          this._element.replaceWith(t2), this._element = t2, this._element.focus(), this._rippleInSpan = false;
        }
        _durationToMsNumber(t2) {
          return Number(t2.replace("ms", "").replace("s", "000"));
        }
        _getConfig(t2 = {}) {
          const e2 = M.getDataAttributes(this._element);
          return t2 = { ...na, ...e2, ...t2 }, h(Xr, t2, sa), t2;
        }
        _getDiameter({ offsetX: t2, offsetY: e2, height: i2, width: n2 }) {
          const s2 = e2 <= i2 / 2, o2 = t2 <= n2 / 2, r2 = (t3, e3) => Math.sqrt(t3 ** 2 + e3 ** 2), a2 = e2 === i2 / 2 && t2 === n2 / 2, l2 = true === s2 && false === o2, c2 = true === s2 && true === o2, h2 = false === s2 && true === o2, d2 = false === s2 && false === o2, u2 = { topLeft: r2(t2, e2), topRight: r2(n2 - t2, e2), bottomLeft: r2(t2, i2 - e2), bottomRight: r2(n2 - t2, i2 - e2) };
          let f2 = 0;
          return a2 || d2 ? f2 = u2.topLeft : h2 ? f2 = u2.topRight : c2 ? f2 = u2.bottomRight : l2 && (f2 = u2.bottomLeft), 2 * f2;
        }
        _appendRipple(t2, e2) {
          e2.appendChild(t2), setTimeout(() => {
            M.addClass(t2, "active");
          }, 50);
        }
        _toggleUnbound(t2) {
          true === this._options.rippleUnbound ? M.addClass(t2, ta) : t2.classList.remove(ta);
        }
        _addColor(t2, e2) {
          if (ia.find((t3) => t3 === this._options.rippleColor.toLowerCase()))
            M.addClass(e2, `${Qr}-${this._options.rippleColor.toLowerCase()}`);
          else {
            const e3 = this._colorToRGB(this._options.rippleColor).join(","), i2 = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%".split("{{color}}").join(`${e3}`);
            t2.style.backgroundImage = `radial-gradient(circle, ${i2})`;
          }
        }
        _removeOldColorClasses(t2) {
          const e2 = new RegExp(`${Qr}-[a-z]+`, "gi");
          (t2.classList.value.match(e2) || []).forEach((e3) => {
            t2.classList.remove(e3);
          });
        }
        _colorToRGB(t2) {
          return "transparent" === t2.toLowerCase() ? ea : "#" === t2[0] ? ((e2 = t2).length < 7 && (e2 = `#${e2[1]}${e2[1]}${e2[2]}${e2[2]}${e2[3]}${e2[3]}`), [parseInt(e2.substr(1, 2), 16), parseInt(e2.substr(3, 2), 16), parseInt(e2.substr(5, 2), 16)]) : (-1 === t2.indexOf("rgb") && (t2 = function(t3) {
            const e3 = document.body.appendChild(document.createElement("fictum")), i2 = "rgb(1, 2, 3)";
            return e3.style.color = i2, e3.style.color !== i2 ? ea : (e3.style.color = t3, e3.style.color === i2 || "" === e3.style.color ? ea : (t3 = getComputedStyle(e3).color, document.body.removeChild(e3), t3));
          }(t2)), 0 === t2.indexOf("rgb") ? function(t3) {
            return (t3 = t3.match(/[.\d]+/g).map((t4) => +Number(t4))).length = 3, t3;
          }(t2) : ea);
          var e2;
        }
        static autoInitial(t2) {
          return function(e2) {
            t2._autoInit(e2);
          };
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            return s.getData(this, "mdb.ripple") ? null : new oa(this, t2);
          });
        }
      }
      const ra = "thumb", aa = "thumb-active", la = `.${ra}`;
      class ca extends Bo {
        constructor(t2) {
          super(t2), this._initiated = false, this._thumb = null, this._element && (this.init(), M.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true), Et(this.constructor));
        }
        static get NAME() {
          return "range";
        }
        get rangeInput() {
          return S.findOne("input[type=range]", this._element);
        }
        init() {
          this._initiated || (this._addThumb(), this._thumbUpdate(), this._handleEvents(), this._initiated = true);
        }
        dispose() {
          this._disposeEvents(), M.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
        }
        _addThumb() {
          const t2 = m("span");
          M.addClass(t2, ra), t2.innerHTML = '<span class="thumb-value"></span>', this._element.append(t2), this._thumb = S.findOne(la, this._element);
        }
        _handleEvents() {
          D.on(this.rangeInput, "mousedown", () => this._showThumb()), D.on(this.rangeInput, "mouseup", () => this._hideThumb()), D.on(this.rangeInput, "touchstart", () => this._showThumb()), D.on(this.rangeInput, "touchend", () => this._hideThumb()), D.on(this.rangeInput, "input", () => this._thumbUpdate());
        }
        _disposeEvents() {
          D.off(this.rangeInput, "mousedown"), D.off(this.rangeInput, "mouseup"), D.off(this.rangeInput, "touchstart"), D.off(this.rangeInput, "touchend"), D.off(this.rangeInput, "input");
        }
        _showThumb() {
          M.addClass(this._thumb, aa);
        }
        _hideThumb() {
          M.removeClass(this._thumb, aa);
        }
        _thumbUpdate() {
          const t2 = this.rangeInput, e2 = t2.value, i2 = t2.min ? t2.min : 0, n2 = t2.max ? t2.max : 100;
          S.findOne(".thumb-value", this._thumb).textContent = e2;
          const s2 = Number(100 * (e2 - i2) / (n2 - i2));
          M.style(this._thumb, { left: `calc(${s2}% + (${8 - 0.15 * s2}px))` });
        }
        static jQueryInterface(t2, e2) {
          return this.each(function() {
            let i2 = s.getData(this, "mdb.range");
            const n2 = "object" == typeof t2 && t2;
            if ((i2 || !/dispose/.test(t2)) && (i2 || (i2 = new ca(this, n2)), "string" == typeof t2)) {
              if (void 0 === i2[t2])
                throw new TypeError(`No method named "${t2}"`);
              i2[t2](e2);
            }
          });
        }
      }
      const ha = /* @__PURE__ */ new Map(), da = (t2, e2) => {
        const i2 = t2;
        ha.has(t2.name) || (D.one(document, "mousedown", e2, i2.autoInitial(new i2())), ha.set(t2.name, true));
      }, ua = { alert: { name: "Alert", selector: "[data-mdb-alert-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = t2;
        ha.has(t2.name) || (Ut(i2), ha.set(t2.name, true)), S.find(e2).forEach((t3) => i2.getOrCreateInstance(t3));
      } }, button: { name: "Button", selector: "[data-mdb-button-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = t2, n2 = `click.bs.${t2.name}.data-api`;
        ha.has(t2.name) || (D.on(document, n2, e2, (t3) => {
          t3.preventDefault();
          const n3 = t3.target.closest(e2);
          i2.getOrCreateInstance(n3).toggle();
        }), ha.set(t2.name, true)), S.find(e2).forEach((t3) => i2.getOrCreateInstance(t3));
      } }, carousel: { name: "Carousel", selector: "[data-mdb-carousel-init]", isToggler: true, callback: (t2, e2) => {
        if (ha.has(t2.name))
          return;
        const i2 = `click.bs.${t2.name}.data-api`, n2 = t2, s2 = `load.bs.${t2.name}.data-api`, o2 = e2;
        D.on(document, i2, "[data-mdb-slide], [data-mdb-slide-to]", function(t3) {
          const e3 = a(this);
          if (!e3 || !e3.classList.contains("carousel"))
            return;
          t3.preventDefault();
          const i3 = n2.getOrCreateInstance(e3), s3 = this.getAttribute("data-mdb-slide-to");
          return s3 ? (i3.to(s3), void i3._maybeEnableCycle()) : "next" === M.getDataAttribute(this, "slide") ? (i3.next(), void i3._maybeEnableCycle()) : (i3.prev(), void i3._maybeEnableCycle());
        }), D.on(window, s2, () => {
          S.find(o2).forEach((t3) => {
            n2.getOrCreateInstance(t3);
          });
        }), ha.set(t2.name, true);
      } }, collapse: { name: "Collapse", selector: "[data-mdb-collapse-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = `click.bs.${t2.name}.data-api`, n2 = e2, s2 = t2;
        ha.has(t2.name) || (D.on(document, i2, n2, function(t3) {
          ("A" === t3.target.tagName || t3.delegateTarget && "A" === t3.delegateTarget.tagName) && t3.preventDefault();
          const e3 = r(this);
          S.find(e3).forEach((t4) => {
            s2.getOrCreateInstance(t4, { toggle: false }).toggle();
          });
        }), ha.set(t2.name, true)), S.find(n2).forEach((t3) => {
          const e3 = r(t3);
          S.find(e3).forEach((t4) => {
            s2.getOrCreateInstance(t4, { toggle: false });
          });
        });
      } }, dropdown: { name: "Dropdown", selector: "[data-mdb-dropdown-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = `click.bs.${t2.name}.data-api`, n2 = `keydown.bs.${t2.name}.data-api`, s2 = `keyup.bs.${t2.name}.data-api`, o2 = `[data-mdb-${t2.NAME}-initialized]`, r2 = t2;
        ha.has(t2.name) || (D.on(document, n2, o2, r2.dataApiKeydownHandler), D.on(document, n2, ".dropdown-menu", r2.dataApiKeydownHandler), D.on(document, i2, r2.clearMenus), D.on(document, s2, r2.clearMenus), D.on(document, i2, o2, function(t3) {
          t3.preventDefault(), r2.getOrCreateInstance(this).toggle();
        })), ha.set(t2.name, true), S.find(e2).forEach((t3) => {
          r2.getOrCreateInstance(t3);
        });
      } }, modal: { name: "Modal", selector: "[data-mdb-modal-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = `click.bs.${t2.name}.data-api`, n2 = t2, s2 = `show.bs.${t2.name}`, o2 = `hidden.bs.${t2.name}`;
        ha.has(t2.name) || (D.on(document, i2, e2, function(t3) {
          const e3 = a(this);
          ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), D.one(e3, s2, (t4) => {
            t4.defaultPrevented || D.one(e3, o2, () => {
              d(this) && this.focus();
            });
          });
          S.find(".modal.show").forEach((t4) => {
            t4.classList.contains("modal-non-invasive-show") || n2.getInstance(t4).hide();
          });
          n2.getOrCreateInstance(e3).toggle(this);
        }), Ut(n2), ha.set(t2.name, true)), S.find(e2).forEach((t3) => {
          const e3 = r(t3), i3 = S.findOne(e3);
          n2.getOrCreateInstance(i3);
        });
      } }, offcanvas: { name: "Offcanvas", selector: "[data-mdb-offcanvas-init]", isToggler: true, callback: (t2, e2) => {
        if (ha.has(t2.name))
          return;
        const i2 = `click.bs.${t2.name}.data-api`, n2 = ".offcanvas.show", s2 = t2, o2 = `hidden.bs.${t2.name}`, r2 = `load.bs.${t2.name}.data-api`, l2 = `resize.bs.${t2.name}`;
        D.on(document, i2, e2, function(t3) {
          const e3 = a(this);
          if (["A", "AREA"].includes(this.tagName) && t3.preventDefault(), u(this))
            return;
          D.one(e3, o2, () => {
            d(this) && this.focus();
          });
          const i3 = S.findOne(n2);
          i3 && i3 !== e3 && s2.getInstance(i3).hide();
          s2.getOrCreateInstance(e3).toggle(this);
        }), D.on(window, r2, () => {
          S.find(n2).forEach((t3) => {
            s2.getOrCreateInstance(t3).show();
          });
        }), D.on(window, l2, () => {
          S.find("[aria-modal][class*=show][class*=offcanvas-]").forEach((t3) => {
            "fixed" !== getComputedStyle(t3).position && s2.getOrCreateInstance(t3).hide();
          });
        }), Ut(s2), ha.set(t2.name, true);
      } }, scrollspy: { name: "ScrollSpy", selector: "[data-mdb-scrollspy-init]", isToggler: true, callback: (t2, e2) => {
        if (ha.has(t2.name))
          return;
        const i2 = `load.bs.${t2.name}.data-api`, n2 = t2;
        D.on(window, i2, () => {
          S.find(e2).forEach((t3) => {
            n2.getOrCreateInstance(t3);
          });
        }), ha.set(t2.name, true);
      } }, tab: { name: "Tab", selector: "[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = `load.bs.${t2.name}.data-api`, n2 = `click.bs.${t2.name}.data-api`, s2 = "active", o2 = `.${s2}[data-mdb-tab-init], .${s2}[data-mdb-pill-init], .${s2}[data-mdb-toggle="list"]`, r2 = t2;
        ha.has(t2.name) || (D.on(document, n2, e2, function(t3) {
          ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), u(this) || r2.getOrCreateInstance(this).show();
        }), D.on(window, i2, () => {
          S.find(o2).forEach((t3) => {
            r2.getOrCreateInstance(t3);
          });
        }), ha.set(t2.name, true));
      } }, toast: { name: "Toast", selector: "[data-mdb-toast-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = t2;
        ha.has(t2.name) || (Ut(i2), ha.set(t2.name, true)), S.find(e2).forEach((t3) => i2.getOrCreateInstance(t3));
      } }, tooltip: { name: "Tooltip", selector: "[data-mdb-tooltip-init]", isToggler: false }, input: { name: "Input", selector: "[data-mdb-input-init]", isToggler: true, callback: (t2, e2) => {
        const i2 = e2, n2 = `${i2} input`, s2 = `${i2} textarea`, o2 = t2;
        ha.has(t2.name) || (D.on(document, "focus", n2, o2.activate(new o2())), D.on(document, "input", n2, o2.activate(new o2())), D.on(document, "blur", n2, o2.deactivate(new o2())), D.on(document, "focus", s2, o2.activate(new o2())), D.on(document, "input", s2, o2.activate(new o2())), D.on(document, "blur", s2, o2.deactivate(new o2())), D.on(window, "shown.bs.modal", (t3) => {
          S.find(n2, t3.target).forEach((t4) => {
            const e3 = o2.getInstance(t4.parentNode);
            e3 && e3.update();
          }), S.find(s2, t3.target).forEach((t4) => {
            const e3 = o2.getInstance(t4.parentNode);
            e3 && e3.update();
          });
        }), D.on(window, "shown.bs.dropdown", (t3) => {
          const e3 = t3.target.parentNode.querySelector(".dropdown-menu");
          e3 && (S.find(n2, e3).forEach((t4) => {
            const e4 = o2.getInstance(t4.parentNode);
            e4 && e4.update();
          }), S.find(s2, e3).forEach((t4) => {
            const e4 = o2.getInstance(t4.parentNode);
            e4 && e4.update();
          }));
        }), D.on(window, "shown.bs.tab", (t3) => {
          let e3;
          e3 = t3.target.href ? t3.target.href.split("#")[1] : M.getDataAttribute(t3.target, "target").split("#")[1];
          const i3 = S.findOne(`#${e3}`);
          S.find(n2, i3).forEach((t4) => {
            const e4 = o2.getInstance(t4.parentNode);
            e4 && e4.update();
          }), S.find(s2, i3).forEach((t4) => {
            const e4 = o2.getInstance(t4.parentNode);
            e4 && e4.update();
          });
        }), D.on(window, "reset", (t3) => {
          S.find(n2, t3.target).forEach((t4) => {
            const e3 = o2.getInstance(t4.parentNode);
            e3 && e3.forceInactive();
          }), S.find(s2, t3.target).forEach((t4) => {
            const e3 = o2.getInstance(t4.parentNode);
            e3 && e3.forceInactive();
          });
        }), D.on(window, "onautocomplete", (t3) => {
          const e3 = o2.getInstance(t3.target.parentNode);
          e3 && t3.cancelable && e3.forceActive();
        }), ha.set(t2.name, true)), S.find(i2).map((t3) => o2.getOrCreateInstance(t3));
      } }, range: { name: "Range", selector: "[data-mdb-range-init]", isToggler: false }, ripple: { name: "Ripple", selector: "[data-mdb-ripple-init]", isToggler: true, callback: da }, popover: { name: "Popover", selector: "[data-mdb-popover-init]", isToggler: false, callback: da } }, fa = new class {
        constructor(t2) {
          i(this, "init", (t3) => {
            t3.forEach((t4) => At(t4));
          }), i(this, "initMDB", (t3, e2 = false) => {
            const i2 = Object.keys(Ct).map((i3) => {
              if (Boolean(document.querySelector(Ct[i3].selector))) {
                const n2 = t3[Ct[i3].name];
                return n2 || wt.get(i3) || !e2 || console.warn(`Please import ${Ct[i3].name} from "MDB" package and add it to a object parameter inside "initMDB" function`), n2;
              }
              return null;
            });
            this.init(i2);
          }), Ct = t2;
        }
      }(ua).initMDB;
      fa({ Alert: Te, Button: Ht, Carousel: ii, Collapse: dr, Offcanvas: be, Dropdown: Kr, Input: Xo, Modal: wi, Popover: Ts, Ripple: oa, ScrollSpy: Ws, Tab: vo, Toast: Ro, Tooltip: Eo, Range: ca }), t.Alert = Te, t.Button = Ht, t.Carousel = ii, t.Collapse = dr, t.Dropdown = Kr, t.Input = Xo, t.Modal = wi, t.Offcanvas = be, t.Popover = Ts, t.Range = ca, t.Ripple = oa, t.ScrollSpy = Ws, t.Tab = vo, t.Toast = Ro, t.Tooltip = Eo, t.initMDB = fa, Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
    });
  }
});
export default require_mdb_umd_min();
/*! Bundled license information:

mdb-ui-kit/js/mdb.umd.min.js:
  (*!
  * MDB5
  * Version: FREE 8.2.0
  *
  *
  * Copyright: Material Design for Bootstrap
  * https://mdbootstrap.com/
  *
  * Read the license: https://mdbootstrap.com/general/license/
  *
  *
  * Documentation: https://mdbootstrap.com/docs/standard/
  *
  * Support: https://mdbootstrap.com/support/
  *
  * Contact: contact@mdbootstrap.com
  *
  *)
*/
//# sourceMappingURL=mdb-ui-kit_js_mdb__umd__min__js.js.map
